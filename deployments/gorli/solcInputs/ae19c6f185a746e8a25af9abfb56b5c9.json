{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IEscrow.sol": {
      "content": "pragma solidity 0.8.9;\ninterface IEscrow {\n    struct Deposit {\n        uint amount;\n        bool isERC4626;\n        address asset; // eip4626 asset else the erc20 token itself\n        uint8 assetDecimals;\n    }\n\n    event AddCollateral(address indexed token, uint indexed amount);\n\n    event RemoveCollateral(address indexed token, uint indexed amount);\n\n    event EnableCollateral(address indexed token, int indexed price);\n    \n    event Liquidate(address indexed token, uint indexed amount);\n\n    error InvalidCollateral();\n\n    error CallerAccessDenied();\n\n    error UnderCollateralized();\n\n    error NotLiquidatable();\n\n    // State Var Getters\n\n    function loan() external returns(address);\n\n    function borrower() external returns(address);\n\n    function minimumCollateralRatio() external returns(uint256);\n\n\n    // Functions \n\n    function isLiquidatable() external returns(bool);\n\n    function updateLoan(address loan_) external returns(bool);\n\n    function getCollateralRatio() external returns(uint);\n\n    function getCollateralValue() external returns(uint);\n\n    function enableCollateral(address token) external returns(bool);\n\n    function addCollateral(uint amount, address token) external returns(uint);\n\n    function releaseCollateral(uint amount, address token, address to) external returns(uint);\n    \n    function liquidate(uint amount, address token, address to) external returns(bool);\n}\n"
    },
    "contracts/modules/escrow/Escrow.sol": {
      "content": "pragma solidity 0.8.9;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IEscrow} from \"../../interfaces/IEscrow.sol\";\nimport {IOracle} from \"../../interfaces/IOracle.sol\";\nimport {ILineOfCredit} from \"../../interfaces/ILineOfCredit.sol\";\nimport {CreditLib} from \"../../utils/CreditLib.sol\";\n\ncontract Escrow is IEscrow {\n    using SafeERC20 for IERC20;\n\n    // the minimum value of the collateral in relation to the outstanding debt e.g. 10% of outstanding debt\n    uint256 public minimumCollateralRatio;\n\n    // return if have collateral but no debt\n    uint256 constant MAX_INT =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    // Stakeholders and contracts used in Escrow\n    address public immutable oracle;\n    address public immutable borrower;\n    address public loan;\n\n    // tracking tokens that were deposited\n    address[] private _collateralTokens;\n\n    // mapping if lenders allow token as collateral. ensures uniqueness in tokensUsedAsCollateral\n    mapping(address => bool) private enabled;\n\n    // tokens used as collateral (must be able to value with oracle)\n    mapping(address => Deposit) public deposited;\n\n    constructor(\n        uint256 _minimumCollateralRatio,\n        address _oracle,\n        address _loan,\n        address _borrower\n    ) {\n        minimumCollateralRatio = _minimumCollateralRatio;\n        oracle = _oracle;\n        loan = _loan;\n        borrower = _borrower;\n    }\n\n    function isLiquidatable() external returns(bool) {\n      return _getLatestCollateralRatio() < minimumCollateralRatio;\n    }\n\n    function updateLoan(address loan_) external returns(bool) {\n      require(msg.sender == loan);\n      loan = loan_;\n      return true;\n    }\n\n    /**\n     * @notice updates the cratio according to the collateral value vs loan value\n     * @dev calls accrue interest on the loan contract to update the latest interest payable\n     * @return the updated collateral ratio in 18 decimals\n     */\n    function _getLatestCollateralRatio() internal returns (uint256) {\n        (uint256 principal, uint256 interest)  = ILineOfCredit(loan).updateOutstandingDebt();\n        uint256 debtValue =  principal + interest;\n        uint256 collateralValue = _getCollateralValue();\n        if (collateralValue == 0) return 0;\n        if (debtValue == 0) return MAX_INT;\n\n        return _percent(collateralValue, debtValue, 18);\n    }\n\n    /**\n     * @notice - computes the ratio of one value to another\n               - e.g. _percent(100, 100, 18) = 1 ether = 100%\n     * @param numerator - value to compare\n     * @param denominator - value to compare against\n     * @param precision - number of decimal places of accuracy to return in answer \n     * @return quotient -  the result of num / denom\n    */\n    function _percent(\n        uint256 numerator,\n        uint256 denominator,\n        uint256 precision\n    ) internal pure returns (uint256 quotient) {\n        uint256 _numerator = numerator * 10**(precision + 1);\n        // with rounding of last digit\n        uint256 _quotient = ((_numerator / denominator) + 5) / 10;\n        return (_quotient);\n    }\n\n    /**\n\n    * @dev calculate the USD value of all the collateral stored\n    * @return - the collateral's USD value in 8 decimals\n    */\n    function _getCollateralValue() internal returns (uint256) {\n        uint256 collateralValue = 0;\n        // gas savings\n        uint256 length = _collateralTokens.length;\n        IOracle o = IOracle(oracle); \n        Deposit memory d;\n        for (uint256 i = 0; i < length; i++) {\n            address token = _collateralTokens[i];\n            d = deposited[token];\n            uint256 deposit = d.amount;\n            if (deposit != 0) {\n                if (d.isERC4626) {\n                    // this conversion could shift, hence it is best to get it each time\n                    (bool success, bytes memory assetAmount) = token.call(\n                        abi.encodeWithSignature(\n                            \"previewRedeem(uint256)\",\n                            deposit\n                        )\n                    );\n                    if (!success) continue;\n                    deposit = abi.decode(assetAmount, (uint256));\n                }\n                collateralValue += CreditLib.getValuation(o, d.asset, deposit, d.assetDecimals);\n            }\n        }\n\n        return collateralValue;\n    }\n\n    /**\n     * @notice add collateral to your position\n     * @dev updates cratio\n     * @dev requires that the token deposited can be valued by the escrow's oracle & the depositor has approved this contract\n     * @dev - callable by anyone\n     * @param amount - the amount of collateral to add\n     * @param token - the token address of the deposited token\n     * @return - the updated cratio\n     */\n    function addCollateral(uint256 amount, address token)\n        external\n        returns (uint256)\n    {\n        require(amount > 0);\n        if(!enabled[token])  { revert InvalidCollateral(); }\n\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n\n        deposited[token].amount += amount;\n\n        emit AddCollateral(token, amount);\n\n        return _getLatestCollateralRatio();\n    }\n\n    /**\n     * @notice - allows  the loans arbiter to  enable thdeposits of an asset\n     *        - gives  better risk segmentation forlenders\n     * @dev - whitelisting protects against malicious 4626 tokens and DoS attacks\n     *       - only need to allow once. Can not disable collateral once enabled.\n     * @param token - the token to all borrow to deposit as collateral\n     */\n    function enableCollateral(address token) external returns (bool) {\n        require(msg.sender == ILineOfCredit(loan).arbiter());\n\n        _enableToken(token);\n\n        return true;\n    }\n\n  /**\n    * @notice track the tokens used as collateral. Ensures uniqueness,\n              flags if its a EIP 4626 token, and gets its decimals\n    * @dev - if 4626 token then Deposit.asset s the underlying asset, not the 4626 token\n    * return bool - if collateral is now enabled or not.\n    */\n    function _enableToken(address token) internal returns(bool) {\n        bool isEnabled = enabled[token];\n        if (!isEnabled) {\n            Deposit memory deposit = deposited[token]; // gas savings\n\n            (bool passed, bytes memory tokenAddrBytes) = token.call(\n                abi.encodeWithSignature(\"asset()\")\n            );\n\n            bool is4626 = tokenAddrBytes.length > 0 && passed;\n            deposit.isERC4626 = is4626;\n            // if 4626 save the underlying token to use for oracle pricing\n            deposit.asset = !is4626 ? token : abi.decode(tokenAddrBytes, (address));\n\n            int price = IOracle(oracle).getLatestAnswer(deposit.asset);\n            if(price <= 0) { revert InvalidCollateral(); }\n\n            (bool successDecimals, bytes memory decimalBytes) = deposit\n                .asset\n                .call(abi.encodeWithSignature(\"decimals()\"));\n            if (decimalBytes.length > 0 && successDecimals) {\n                deposit.assetDecimals = abi.decode(decimalBytes, (uint8));\n            } else {\n                deposit.assetDecimals = 18;\n            }\n\n            // update collateral settings\n            enabled[token] = true;\n            deposited[token] = deposit;\n            _collateralTokens.push(token);\n            emit EnableCollateral(deposit.asset, price);\n            return true;\n        }\n\n        return isEnabled;\n    }\n\n    /**\n     * @notice remove collateral from your position. Must remain above min collateral ratio\n     * @dev callable by `borrower`\n     * @dev updates cratio\n     * @param amount - the amount of collateral to release\n     * @param token - the token address to withdraw\n     * @param to - who should receive the funds\n     * @return - the updated cratio\n     */\n    function releaseCollateral(\n        uint256 amount,\n        address token,\n        address to\n    ) external returns (uint256) {\n        require(amount > 0);\n        if(msg.sender != borrower) { revert CallerAccessDenied(); }\n        if(deposited[token].amount < amount) { revert InvalidCollateral(); }\n        deposited[token].amount -= amount;\n        IERC20(token).safeTransfer(to, amount);\n        uint256 cratio = _getLatestCollateralRatio();\n        if(cratio < minimumCollateralRatio) { revert UnderCollateralized(); }\n        \n        emit RemoveCollateral(token, amount);\n\n        return cratio;\n    }\n\n    /**\n     * @notice calculates the cratio\n     * @dev callable by anyone\n     * @return - the calculated cratio\n     */\n    function getCollateralRatio() external returns (uint256) {\n        return _getLatestCollateralRatio();\n    }\n\n    /**\n     * @notice calculates the collateral value in USD to 8 decimals\n     * @dev callable by anyone\n     * @return - the calculated collateral value to 8 decimals\n     */\n    function getCollateralValue() external returns (uint256) {\n        return _getCollateralValue();\n    }\n\n    /**\n     * @notice liquidates borrowers collateral by token and amount\n     * @dev requires that the cratio is at or below the liquidation threshold\n     * @dev callable by `loan`\n     * @param amount - the amount of tokens to liquidate\n     * @param token - the address of the token to draw funds from\n     * @param to - the address to receive the funds\n     * @return - true if successful\n     */\n    function liquidate(\n        uint256 amount,\n        address token,\n        address to\n    ) external returns (bool) {\n        require(amount > 0);\n        if(msg.sender != loan) { revert CallerAccessDenied(); }\n        if(deposited[token].amount < amount) { revert InvalidCollateral(); }\n        if(minimumCollateralRatio < _getLatestCollateralRatio()) { revert NotLiquidatable(); }\n\n        deposited[token].amount -= amount;\n        \n        IERC20(token).safeTransfer(to, amount);\n\n        emit Liquidate(token, amount);\n\n        return true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IOracle.sol": {
      "content": "pragma solidity 0.8.9;\n\ninterface IOracle {\n    /** current price for token asset. denominated in USD */\n    function getLatestAnswer(address token) external returns(int);\n}\n"
    },
    "contracts/interfaces/ILineOfCredit.sol": {
      "content": "pragma solidity 0.8.9;\n\nimport { LoanLib } from \"../utils/LoanLib.sol\";\nimport { ILoan } from \"./ILoan.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\n\ninterface ILineOfCredit is ILoan {\n  // Lender data\n  struct Credit {\n    //  all denominated in token, not USD\n    uint256 deposit;          // total liquidity provided by lender for token\n    uint256 principal;        // amount actively lent out\n    uint256 interestAccrued;  // interest accrued but not repaid\n    uint256 interestRepaid;   // interest repaid by borrower but not withdrawn by lender\n    uint8 decimals;           // decimals of credit token for calcs\n    address token;            // token being lent out\n    address lender;           // person to repay\n  }\n\n  event SetRates(bytes32 indexed id, uint128 indexed drawnRate, uint128 indexed facilityRate);\n\n\n  // Access Errors\n  error NotActive();\n  error NotBorrowing();\n  error CallerAccessDenied();\n  \n  // Tokens\n  error TokenTransferFailed();\n  error NoTokenPrice();\n\n  // Loan\n  error BadModule(address module);\n  error NoLiquidity(bytes32 position);\n  error PositionExists();\n  error CloseFailedWithPrincipal();\n\n  function init() external returns(LoanLib.STATUS);\n\n  function addCredit(\n    uint128 drate,\n    uint128 frate,\n    uint256 amount,\n    address token,\n    address lender\n  ) external returns(bytes32);\n\n  function setRates(\n    bytes32 id,\n    uint128 drate,\n    uint128 frate\n  ) external returns(bool);\n\n  function increaseCredit(bytes32 id, uint256 amount) external returns(bool);\n\n  function borrow(bytes32 id, uint256 amount) external returns(bool);\n  function depositAndRepay(uint256 amount) external returns(bool);\n  function depositAndClose() external returns(bool);\n  function close(bytes32 id) external returns(bool);\n\n  function withdraw(bytes32 id, uint256 amount) external returns(bool);\n\n  function accrueInterest() external returns(bool);\n  function updateOutstandingDebt() external returns(uint256, uint256);\n  function healthcheck() external returns(LoanLib.STATUS);\n\n  function borrower() external returns(address);\n  function arbiter() external returns(address);\n  function oracle() external returns(IOracle);\n}\n"
    },
    "contracts/utils/CreditLib.sol": {
      "content": "pragma solidity 0.8.9;\nimport { ILineOfCredit } from \"../interfaces/ILineOfCredit.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\nimport { IInterestRateCredit } from \"../interfaces/IInterestRateCredit.sol\";\nimport { ILoan } from \"../interfaces/ILoan.sol\";\nimport { LoanLib } from \"./LoanLib.sol\";\n\n/**\n  * @title Debt DAO P2P Loan Library\n  * @author Kiba Gateaux\n  * @notice Core logic and variables to be reused across all Debt DAO Marketplace loans\n */\nlibrary CreditLib {\n\n    event AddCredit(\n        address indexed lender,\n        address indexed token,\n        uint256 indexed deposit,\n        bytes32 positionId\n    );\n\n  event WithdrawDeposit(bytes32 indexed id, uint256 indexed amount);\n  // lender removing funds from Loan  principal\n  event WithdrawProfit(bytes32 indexed id, uint256 indexed amount);\n  // lender taking interest earned out of contract\n\n  event InterestAccrued(bytes32 indexed id, uint256 indexed amount);\n  // interest added to borrowers outstanding balance\n\n\n  // Borrower Events\n\n  event Borrow(bytes32 indexed id, uint256 indexed amount);\n  // receive full loan or drawdown on credit\n\n  event RepayInterest(bytes32 indexed id, uint256 indexed amount);\n\n  event RepayPrincipal(bytes32 indexed id, uint256 indexed amount);\n\n\n  error NoTokenPrice();\n\n  error PositionExists();\n\n\n  /**\n   * @dev          - Create deterministic hash id for a debt position on `loan` given position details\n   * @param loan   - loan that debt position exists on\n   * @param lender - address managing debt position\n   * @param token  - token that is being lent out in debt position\n   * @return positionId\n   */\n  function computePositionId(\n    address loan,\n    address lender,\n    address token\n  )\n    external pure\n    returns(bytes32)\n  {\n    return _computePositionId(loan, lender, token);\n  }\n\n  function _computePositionId(\n    address loan,\n    address lender,\n    address token\n  )\n    internal pure\n    returns(bytes32)\n  {\n    return keccak256(abi.encode(loan, lender, token));\n  }\n\n\n    function getOutstandingDebt(\n      ILineOfCredit.Credit memory credit,\n      bytes32 id,\n      address oracle,\n      address interestRate\n    )\n      external\n      returns (ILineOfCredit.Credit memory c, uint256 principal, uint256 interest)\n    {\n        c = _accrue(credit, id, IInterestRateCredit(interestRate)); // Issue is accruing interest from here\n\n        int256 price = IOracle(oracle).getLatestAnswer(c.token);\n\n        principal += _calculateValue(\n            price,\n            c.principal,\n            c.decimals\n        );\n        interest += _calculateValue(\n            price,\n            c.interestAccrued,\n            c.decimals\n        );\n\n        return (c, principal, interest);\n  }\n\n   /**\n     * @notice         - Gets total valuation for amount of tokens using given oracle. \n     * @dev            - Assumes oracles all return answers in USD with 1e8 decimals\n                       - Does not check if price < 0. HAndled in Oracle or Loan\n     * @param oracle   - oracle contract specified by loan getting valuation\n     * @param token    - token to value on oracle\n     * @param amount   - token amount\n     * @param decimals - token decimals\n     * @return         - total value in usd of all tokens \n     */\n    function getValuation(\n      IOracle oracle,\n      address token,\n      uint256 amount,\n      uint8 decimals\n    )\n      external\n      returns(uint256)\n    {\n      return _calculateValue(oracle.getLatestAnswer(token), amount, decimals);\n    }\n\n    /**\n     * @notice\n     * @dev            - Assumes oracles all return answers in USD with 1e8 decimals\n                       - Does not check if price < 0. HAndled in Oracle or Loan\n     * @param price    - oracle price of asset. 8 decimals\n     * @param amount   - amount of tokens vbeing valued.\n     * @param decimals - token decimals to remove for usd price\n     * @return         - total USD value of amount in 8 decimals \n     */\n    function calculateValue(\n      int price,\n      uint256 amount,\n      uint8 decimals\n    )\n      external pure\n      returns(uint256)\n    {\n      return _calculateValue(price, amount, decimals);\n    }\n\n\n      /**\n     * @notice         - calculates value of tokens and denominates in USD 8\n     * @dev            - Assumes all oracles return USD responses in 1e8 decimals\n     * @param price    - oracle price of asset. 8 decimals\n     * @param amount   - amount of tokens vbeing valued.\n     * @param decimals - token decimals to remove for usd price\n     * @return         - total value in usd of all tokens \n     */\n    function _calculateValue(\n      int price,\n      uint256 amount,\n      uint8 decimals\n    )\n      internal pure\n      returns(uint256)\n    {\n      return price <= 0 ? 0 : (amount * uint(price)) / (1 * 10 ** decimals);\n    }\n\n  \n\n  function create(\n      bytes32 id,\n      uint256 amount,\n      address lender,\n      address token,\n      address oracle\n  )\n      external \n      returns(ILineOfCredit.Credit memory credit)\n  {\n      return _create(id, amount, lender, token, oracle);\n  }\n\n  function _create(\n      bytes32 id,\n      uint256 amount,\n      address lender,\n      address token,\n      address oracle\n  )\n      internal \n      returns(ILineOfCredit.Credit memory credit)\n  {\n      int price = IOracle(oracle).getLatestAnswer(token);\n      if(price <= 0 ) { revert NoTokenPrice(); }\n\n      (bool passed, bytes memory result) = token.call(\n          abi.encodeWithSignature(\"decimals()\")\n      );\n      uint8 decimals = !passed ? 18 : abi.decode(result, (uint8));\n\n      credit = ILineOfCredit.Credit({\n          lender: lender,\n          token: token,\n          decimals: decimals,\n          deposit: amount,\n          principal: 0,\n          interestAccrued: 0,\n          interestRepaid: 0\n      });\n\n      emit AddCredit(lender, token, amount, id);\n\n      return credit;\n  }\n\n  function repay(\n    ILineOfCredit.Credit memory credit,\n    bytes32 id,\n    uint256 amount\n  )\n    external\n    // TODO don't need to return all uints if we can get events working in library to show up on subgraph\n    returns (ILineOfCredit.Credit memory)\n  { unchecked {\n      if (amount <= credit.interestAccrued) {\n          credit.interestAccrued -= amount;\n          credit.interestRepaid += amount;\n          emit RepayInterest(id, amount);\n          return credit;\n      } else {\n          uint256 interest = credit.interestAccrued;\n          uint256 principalPayment = amount - interest;\n\n          // update individual credit position denominated in token\n          credit.principal -= principalPayment;\n          credit.interestRepaid += interest;\n          credit.interestAccrued = 0;\n\n          emit RepayInterest(id, interest);\n          emit RepayPrincipal(id, principalPayment);\n\n          return credit;\n      }\n  } }\n\n  function withdraw(\n    ILineOfCredit.Credit memory credit,\n    bytes32 id,\n    uint256 amount\n  )\n    external\n    returns (ILineOfCredit.Credit memory)\n  { unchecked {\n      if(amount > credit.deposit - credit.principal + credit.interestRepaid) {\n        revert ILineOfCredit.NoLiquidity(id);\n      }\n\n      if (amount > credit.interestRepaid) {\n          uint256 interest = credit.interestRepaid;\n          amount -= interest;\n\n          credit.deposit -= amount;\n          credit.interestRepaid = 0;\n\n          // emit events before seeting to 0\n          emit WithdrawDeposit(id, amount);\n          emit WithdrawProfit(id, interest);\n\n          return credit;\n      } else {\n          credit.interestRepaid -= amount;\n          emit WithdrawProfit(id, amount);\n          return credit;\n      }\n  } }\n\n\n  function accrue(\n    ILineOfCredit.Credit memory credit,\n    bytes32 id,\n    address interest\n  )\n    external\n    returns (ILineOfCredit.Credit memory)\n  { \n    return _accrue(credit, id, IInterestRateCredit(interest));\n  }\n\n  function _accrue(\n    ILineOfCredit.Credit memory credit,\n    bytes32 id,\n    IInterestRateCredit interest\n  )\n    internal\n    returns (ILineOfCredit.Credit memory)\n  { unchecked {\n      // interest will almost always be less than deposit\n      // low risk of overflow unless extremely high interest rate\n\n      // get token demoninated interest accrued\n      uint256 accruedToken = interest.accrueInterest(\n          id,\n          credit.principal,\n          credit.deposit\n      );\n\n      // update credits balance\n      credit.interestAccrued += accruedToken;\n\n      emit InterestAccrued(id, accruedToken);\n      return credit;\n  } }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/utils/LoanLib.sol": {
      "content": "pragma solidity 0.8.9;\nimport { ILoan } from \"../interfaces/ILoan.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\n/**\n  * @title Debt DAO P2P Loan Library\n  * @author Kiba Gateaux\n  * @notice Core logic and variables to be reused across all Debt DAO Marketplace loans\n */\nlibrary LoanLib {\n    event UpdateLoanStatus(uint256 indexed status); // store as normal uint so it can be indexed in subgraph\n\n    enum STATUS {\n        // ¿hoo dis\n        // Loan has been deployed but terms and conditions are still being signed off by parties\n        UNINITIALIZED,\n        INITIALIZED,\n\n        // ITS ALLLIIIIVVEEE\n        // Loan is operational and actively monitoring status\n        ACTIVE,\n        UNDERCOLLATERALIZED,\n        LIQUIDATABLE, // [#X\n        DELINQUENT,\n\n        // Loan is in distress and paused\n        LIQUIDATING,\n        OVERDRAWN,\n        DEFAULT,\n        ARBITRATION,\n\n        // Lön izz ded\n        // Loan is no longer active, successfully repaid or insolvent\n        REPAID,\n        INSOLVENT\n    }\n\n    function updateStatus(STATUS status, STATUS target) external returns(STATUS) {\n        if (status == target) return status;  // check if it needs updating\n        status = target;            // set storage in Line contract\n        emit UpdateLoanStatus(uint256(status));\n        return status;\n    }\n}\n"
    },
    "contracts/interfaces/ILoan.sol": {
      "content": "pragma solidity 0.8.9;\n\nimport { LoanLib } from \"../utils/LoanLib.sol\";\n\ninterface ILoan {\n\n  // General Events\n  event UpdateLoanStatus(uint256 indexed status); // store as normal uint so it can be indexed in subgraph\n\n  event DeployLoan(\n    address indexed oracle,\n    address indexed arbiter,\n    address indexed borrower\n  );\n\n  // Lender Events\n\n  event AddCredit(\n    address indexed lender,\n    address indexed token,\n    uint256 indexed deposit,\n    bytes32 positionId\n  );\n\n\n   event IncreaseCredit (bytes32 indexed id, uint256 indexed deposit);\n\n  // can reference only id once AddCredit is emitted because it will be stored in subgraph\n  // initialPrinicipal tells us if its a Revolver or Term\n\n  event WithdrawDeposit(bytes32 indexed id, uint256 indexed amount);\n  // lender removing funds from Loan  principal\n  event WithdrawProfit(bytes32 indexed id, uint256 indexed amount);\n  // lender taking interest earned out of contract\n\n  event CloseCreditPosition(bytes32 indexed id);\n  // lender officially repaid in full. if Credit then facility has also been closed.\n\n  event InterestAccrued(bytes32 indexed id, uint256 indexed amount);\n  // interest added to borrowers outstanding balance\n\n\n  // Borrower Events\n\n  event Borrow(bytes32 indexed id, uint256 indexed amount);\n  // receive full loan or drawdown on credit\n\n  event RepayInterest(bytes32 indexed id, uint256 indexed amount);\n\n  event RepayPrincipal(bytes32 indexed id, uint256 indexed amount);\n\n  event Default(bytes32 indexed id);\n}\n"
    },
    "contracts/interfaces/IInterestRateCredit.sol": {
      "content": "pragma solidity ^0.8.9;\n\ninterface IInterestRateCredit {\n  struct Rate {\n    // interest rate on amount currently being borrower\n    // in bps, 4 decimals\n    uint128 drawnRate;\n    // interest rate on amount deposited by lender but not currently being borrowed\n    // in bps, 4 decimals\n    uint128 facilityRate;\n    // timestamp that interest was last accrued on this position\n    uint256 lastAccrued;\n  }\n\n  function accrueInterest(\n    bytes32 positionId,\n    uint256 drawnAmount,\n    uint256 facilityAmount\n  ) external returns(uint256);\n\n  function setRate(\n    bytes32 positionId,\n    uint128 drawnRate,\n    uint128 facilityRate\n  ) external returns(bool);\n}\n"
    },
    "contracts/modules/escrow/Escrow.t.sol": {
      "content": "pragma solidity 0.8.9;\n\nimport { Escrow } from \"./Escrow.sol\";\nimport { DSTest } from  \"../../../lib/ds-test/src/test.sol\";\nimport { LoanLib } from \"../../utils/LoanLib.sol\";\nimport { RevenueToken } from \"../../mock/RevenueToken.sol\";\nimport { RevenueToken4626 } from \"../../mock/RevenueToken4626.sol\";\nimport { SimpleOracle } from \"../../mock/SimpleOracle.sol\";\nimport { MockLoan } from \"../../mock/MockLoan.sol\";\n\ncontract EscrowTest is DSTest {\n\n    Escrow escrow;\n    RevenueToken supportedToken1;\n    RevenueToken supportedToken2;\n    RevenueToken unsupportedToken;\n    RevenueToken4626 token4626;\n    SimpleOracle oracle;\n    MockLoan loan;\n    uint mintAmount = 100 ether;\n    uint MAX_INT = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\n    uint minCollateralRatio = 1 ether; // 100%\n\n    address borrower;\n    address arbiter = address(1);\n\n    function setUp() public {\n        borrower = address(this);\n        // deploy tokens and add oracle prices for valid collateral\n        supportedToken1 = new RevenueToken();\n        supportedToken2 = new RevenueToken();\n        unsupportedToken = new RevenueToken();\n        token4626 = new RevenueToken4626(address(supportedToken1));\n        oracle = new SimpleOracle(address(supportedToken1), address(supportedToken2));\n        loan = new MockLoan(1);\n        // deploy and save escrow\n        _createEscrow(minCollateralRatio, address(oracle), address(loan), borrower);\n        // add escrow to mock loan\n        loan.setEscrow(address(escrow));\n        // allow tokens to be deposited as collateral\n        escrow.enableCollateral(address(supportedToken1));\n        escrow.enableCollateral(address(supportedToken2));\n        _mintAndApprove();\n    }\n\n    function _mintAndApprove() internal {\n        supportedToken1.mint(borrower, mintAmount);\n        supportedToken1.approve(address(escrow), MAX_INT);\n        supportedToken2.mint(borrower, mintAmount);\n        supportedToken2.approve(address(escrow), MAX_INT);\n        unsupportedToken.mint(borrower, mintAmount);\n        unsupportedToken.approve(address(escrow), MAX_INT);\n        token4626.mint(borrower, mintAmount);\n        token4626.approve(address(escrow), MAX_INT);\n    }\n\n    function _createEscrow(\n        uint _minimumCollateralRatio,\n        address _oracle,\n        address _loan,\n        address _borrower\n    ) internal returns(address) {\n        escrow = new Escrow(_minimumCollateralRatio, _oracle, _loan, _borrower);\n\n        return address(escrow);\n    }\n\n    function test_enable_valid_collateral_as_arbiter() public {\n        RevenueToken token = new RevenueToken();\n\n        token.mint(address(this), mintAmount);\n        oracle.changePrice(address(token), 1 ether); // need oracle price to enable\n        escrow.enableCollateral(address(token));\n    }\n\n    function testFail_enable_invalid_collateral_as_arbiter() public {\n        RevenueToken token = new RevenueToken();\n        token.mint(address(this), mintAmount);\n        escrow.enableCollateral(address(token));\n    }\n\n    function testFail_enable_collateral_as_anon() public {\n        loan.setArbiter(address(0xdebf));\n        escrow.enableCollateral(address(supportedToken1));\n    }\n\n    function test_can_get_correct_collateral_value() public {\n        escrow.addCollateral(mintAmount, address(supportedToken1));\n        uint collateralValue = escrow.getCollateralValue();\n        assertEq(collateralValue, (1000 * 1e8) * (mintAmount / 1 ether), \"collateral value should equal the mint amount * price\");\n    }\n    function test_can_get_correct_collateral_value_eip4626() public {\n        token4626.setAssetAddress(address(supportedToken1));\n        escrow.enableCollateral(address(token4626));\n        escrow.addCollateral(mintAmount, address(token4626));\n        uint collateralValue = escrow.getCollateralValue();\n        assertEq(collateralValue, (1000 * 1e8) * (mintAmount / 1 ether), \"collateral value should equal the mint amount * price\");\n    }\n\n    function test_can_add_collateral() public {\n        uint borrowerBalance = supportedToken1.balanceOf(borrower);\n        escrow.addCollateral(mintAmount, address(supportedToken1));\n        assertEq(borrowerBalance, supportedToken1.balanceOf(borrower) + mintAmount, \"borrower should have decreased with collateral deposit\");\n        uint borrowerBalance2 = supportedToken2.balanceOf(borrower);\n        escrow.addCollateral(mintAmount, address(supportedToken2));\n        assertEq(borrowerBalance2, supportedToken2.balanceOf(borrower) + mintAmount, \"borrower should have decreased with collateral deposit\");\n    }\n\n    function test_can_add_collateral_eip4626() public {\n        uint borrowerBalance = token4626.balanceOf(borrower);\n        token4626.setAssetAddress(address(supportedToken2));\n        escrow.enableCollateral(address(token4626));\n        escrow.addCollateral(mintAmount, address(token4626));\n        assertEq(borrowerBalance, token4626.balanceOf(borrower) + mintAmount, \"borrower balance should have been reduced by mintAmount\");\n    }\n\n    function test_can_remove_collateral_eip4626() public {\n        uint borrowerBalance = token4626.balanceOf(borrower);\n        token4626.setAssetAddress(address(supportedToken2));\n        escrow.enableCollateral(address(token4626));\n        escrow.addCollateral(mintAmount, address(token4626));\n        escrow.releaseCollateral(1 ether, address(token4626), borrower);\n        assertEq(1 ether, token4626.balanceOf(borrower), \"should have returned collateral\");\n    }\n\n    function test_can_remove_collateral() public {\n        escrow.addCollateral(mintAmount, address(supportedToken1));\n        uint borrowerBalance = supportedToken1.balanceOf(borrower);\n        escrow.releaseCollateral(1 ether, address(supportedToken1), borrower);\n        assertEq(borrowerBalance + 1 ether, supportedToken1.balanceOf(borrower), \"borrower should have released collateral\");\n    }\n\n    function test_cratio_adjusts_when_collateral_changes() public {\n        loan.setDebtValue(1 ether);\n        escrow.addCollateral(1 ether, address(supportedToken1));\n        uint escrowRatio = escrow.getCollateralRatio();\n        escrow.addCollateral(1 ether, address(supportedToken1));\n        assertEq(escrow.getCollateralRatio(), escrowRatio * 2, \"cratio should be 2x the original\");\n        escrow.addCollateral(1 ether, address(supportedToken2));\n        assertEq(escrow.getCollateralRatio(), escrowRatio * 4, \"cratio should be 4x the original\");\n    }\n\n    function test_cratio_adjusts_when_collateral_price_changes() public {\n        escrow.addCollateral(1 ether, address(supportedToken1));\n        loan.setDebtValue(1000);\n        uint escrowRatio = escrow.getCollateralRatio();\n        oracle.changePrice(address(supportedToken1), 10000 * 1e8);\n        uint newEscrowRatio = escrow.getCollateralRatio();\n        assertEq(newEscrowRatio, escrowRatio * 10, \"new cratio should be 10x the original\");\n    }\n\n    function test_cratio_adjusts_when_collateral_price_changes_eip4626() public {\n        token4626.setAssetAddress(address(supportedToken1));\n        escrow.enableCollateral(address(token4626));\n        escrow.addCollateral(1 ether, address(token4626));\n        loan.setDebtValue(1000);\n        uint escrowRatio = escrow.getCollateralRatio();\n        oracle.changePrice(address(supportedToken1), 10000 * 1e8);\n        uint newEscrowRatio = escrow.getCollateralRatio();\n        assertEq(newEscrowRatio, escrowRatio * 10, \"new cratio should be 10x the original\");\n    }\n\n    function test_can_liquidate() public {\n        escrow.addCollateral(1 ether, address(supportedToken1));\n        escrow.addCollateral(0.9 ether, address(supportedToken2));\n        loan.setDebtValue(2000 ether);\n        assertGt(minCollateralRatio, escrow.getCollateralRatio(), \"should be below the liquidation threshold\");\n        loan.liquidate(0, 1 ether, address(supportedToken1), arbiter);\n        loan.liquidate(0, 0.9 ether, address(supportedToken2), arbiter);\n        assertEq(supportedToken1.balanceOf(arbiter), 1 ether, \"arbiter should have received token 1\");\n        assertEq(supportedToken2.balanceOf(arbiter), 0.9 ether, \"arbiter should have received token 2\");\n    }\n\n    function test_can_liquidate_eip4626() public {\n        token4626.setAssetAddress(address(supportedToken1));\n        escrow.enableCollateral(address(token4626));\n        token4626.setAssetMultiplier(5);\n        escrow.enableCollateral(address(token4626));\n        escrow.addCollateral(1 ether, address(token4626));\n        loan.setDebtValue(2000 ether);\n        assertGt(minCollateralRatio, escrow.getCollateralRatio(), \"should be below the liquidation threshold\");\n        loan.liquidate(0, 1 ether, address(token4626), arbiter);\n        assertEq(token4626.balanceOf(arbiter), 1 ether, \"arbiter should have received 1e18 worth of the 4626 token\");\n    }\n\n    function test_cratio_should_be_max_int_if_no_debt() public {\n        escrow.addCollateral(1 ether, address(supportedToken1));\n        loan.setDebtValue(0);\n        assertEq(escrow.getCollateralRatio(), MAX_INT, \"cratio should be set to MAX\");\n    }\n\n    function test_cratio_values() public {\n        escrow.addCollateral(1 ether, address(supportedToken1));\n        loan.setDebtValue(1000 * 1e8); // 1e18 of supportedToken1 == 1000 * 1e8 (1000 USD)\n        assertEq(escrow.getCollateralRatio(), 1 ether, \"cratio should be at 100%\"); // cratio is at 100%\n        loan.setDebtValue(10 * (1000 * 1e8)); // 10x the collateral value (10000 USD)\n        assertEq(escrow.getCollateralRatio(), 0.1 ether, \"cratio should be at 10%\"); // 10%\n        escrow.addCollateral(1 ether, address(supportedToken2)); // worth 2000 * 1e8 (2000 USD)\n        assertEq(escrow.getCollateralRatio(), 0.3 ether, \"cratio should be at 30%\"); // 30%\n        escrow.addCollateral(10 ether, address(supportedToken2));\n        assertEq(escrow.getCollateralRatio(), 2.3 ether, \"cratio should be at 230%\"); // 230%\n    }\n\n    function test_cratio_should_be_0_if_no_collateral() public {\n        loan.setDebtValue(1000);\n        assertEq(escrow.getCollateralRatio(), 0, \"cratio should be 0\");\n    }\n\n    function test_cratio_values_with_eip4626() public {\n        token4626.setAssetAddress(address(supportedToken2));\n        escrow.enableCollateral(address(token4626));\n        token4626.setAssetMultiplier(2); // share token should be worth double the underlying (which is now supportedToken2)\n        escrow.enableCollateral(address(token4626));\n        escrow.addCollateral(1 ether, address(token4626));\n        loan.setDebtValue(4000 * 1e8); // 1e18 of supportedToken2 * 2 == 4000 * 1e8 (4000 USD)\n        assertEq(escrow.getCollateralRatio(), 1 ether, \"cratio should be 100%\");\n        loan.setDebtValue(10 * (4000 * 1e8)); // 10x the collateral value (40000 USD)\n        assertEq(escrow.getCollateralRatio(), 0.1 ether, \"cratio should be 10%\");\n        escrow.addCollateral(1 ether, address(supportedToken2)); // worth 2000 * 1e8 (2000 USD)\n        assertEq(escrow.getCollateralRatio(), 0.15 ether, \"cratio should be 15%\");\n        escrow.addCollateral(10 ether, address(supportedToken2));\n        assertEq(escrow.getCollateralRatio(), 0.65 ether, \"cratio should be 65%\");\n    }\n\n    function testFail_cannot_remove_collateral_when_under_collateralized() public {\n        escrow.addCollateral(1 ether, address(supportedToken1));\n        loan.setDebtValue(2000 ether);\n        escrow.releaseCollateral(1 ether, address(supportedToken1), borrower);\n    }\n\n    function testFail_cannot_remove_collateral_when_under_collateralized_eip4626() public {\n        token4626.setAssetAddress(address(supportedToken1));\n        escrow.enableCollateral(address(token4626));\n        escrow.addCollateral(1 ether, address(token4626));\n        loan.setDebtValue(2000 ether);\n        escrow.releaseCollateral(1 ether, address(token4626), borrower);\n    }\n\n    function testFail_cannot_liquidate_when_loan_healthy() public {\n        escrow.addCollateral(1 ether, address(supportedToken1));\n        loan.liquidate(0, 1 ether, address(supportedToken1), arbiter);\n    }\n\n    function testFail_cannot_liquidate_when_loan_healthy_eip4626() public {\n        token4626.setAssetAddress(address(supportedToken1));\n        escrow.enableCollateral(address(token4626));\n        escrow.addCollateral(1 ether, address(token4626));\n        loan.liquidate(0, 1 ether, address(token4626), arbiter);\n    }\n\n    function testFail_cannot_add_collateral_if_unsupported_by_oracle() public {\n        escrow.addCollateral(1000, address(unsupportedToken));\n    }\n\n    function testFail_cannot_add_collateral_if_unsupported_by_oracle_eip4626() public {\n        token4626.setAssetAddress(address(unsupportedToken));\n        escrow.enableCollateral(address(token4626));\n        escrow.addCollateral(1000, address(token4626));\n    }\n}\n"
    },
    "lib/ds-test/src/test.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.4.23;\n\ncontract DSTest {\n    event log                    (string);\n    event logs                   (bytes);\n\n    event log_address            (address);\n    event log_bytes32            (bytes32);\n    event log_int                (int);\n    event log_uint               (uint);\n    event log_bytes              (bytes);\n    event log_string             (string);\n\n    event log_named_address      (string key, address val);\n    event log_named_bytes32      (string key, bytes32 val);\n    event log_named_decimal_int  (string key, int val, uint decimals);\n    event log_named_decimal_uint (string key, uint val, uint decimals);\n    event log_named_int          (string key, int val);\n    event log_named_uint         (string key, uint val);\n    event log_named_bytes        (string key, bytes val);\n    event log_named_string       (string key, string val);\n\n    bool public IS_TEST = true;\n    bool public failed;\n\n    address constant HEVM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    modifier mayRevert() { _; }\n    modifier testopts(string memory) { _; }\n\n    function fail() internal {\n        failed = true;\n    }\n\n    modifier logs_gas() {\n        uint startGas = gasleft();\n        _;\n        uint endGas = gasleft();\n        emit log_named_uint(\"gas\", startGas - endGas);\n    }\n\n    function assertTrue(bool condition) internal {\n        if (!condition) {\n            emit log(\"Error: Assertion Failed\");\n            fail();\n        }\n    }\n\n    function assertTrue(bool condition, string memory err) internal {\n        if (!condition) {\n            emit log_named_string(\"Error\", err);\n            assertTrue(condition);\n        }\n    }\n\n    function assertEq(address a, address b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [address]\");\n            emit log_named_address(\"  Expected\", b);\n            emit log_named_address(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(address a, address b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes32 a, bytes32 b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"  Expected\", b);\n            emit log_named_bytes32(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq32(bytes32 a, bytes32 b) internal {\n        assertEq(a, b);\n    }\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\n        assertEq(a, b, err);\n    }\n\n    function assertEq(int a, int b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [int]\");\n            emit log_named_int(\"  Expected\", b);\n            emit log_named_int(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(int a, int b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq(uint a, uint b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [uint]\");\n            emit log_named_uint(\"  Expected\", b);\n            emit log_named_uint(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(uint a, uint b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Expected\", b, decimals);\n            emit log_named_decimal_int(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Expected\", b, decimals);\n            emit log_named_decimal_uint(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGt(uint a, uint b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(uint a, uint b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGt(int a, int b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(int a, int b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGe(uint a, uint b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(uint a, uint b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGe(int a, int b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(int a, int b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLt(uint a, uint b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(uint a, uint b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLt(int a, int b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(int a, int b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLe(uint a, uint b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(uint a, uint b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLe(int a, int b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(int a, int b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a == b not satisfied [string]\");\n            emit log_named_string(\"  Value a\", a);\n            emit log_named_string(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertEq(string memory a, string memory b, string memory err) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\n        ok = true;\n        if (a.length == b.length) {\n            for (uint i = 0; i < a.length; i++) {\n                if (a[i] != b[i]) {\n                    ok = false;\n                }\n            }\n        } else {\n            ok = false;\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b) internal {\n        if (!checkEq0(a, b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"  Expected\", a);\n            emit log_named_bytes(\"    Actual\", b);\n            fail();\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\n        if (!checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertEq0(a, b);\n        }\n    }\n}\n"
    },
    "contracts/mock/RevenueToken.sol": {
      "content": "pragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract RevenueToken is ERC20(\"Token earned as revenue\", \"BRRRR\") {\n\n    function mint(address account, uint256 amount) external returns(bool) {\n        _mint(account, amount);\n        return true;\n    }\n\n    function burnFrom(address account, uint256 amount) external returns(bool) {\n        _burn(account, amount);\n        return true;\n    }\n\n}\n"
    },
    "contracts/mock/RevenueToken4626.sol": {
      "content": "pragma solidity 0.8.9;\n\nimport \"./RevenueToken.sol\";\n\ncontract RevenueToken4626 is RevenueToken {\n\n    address private _asset;\n    uint private _multiplier;\n\n    constructor(address assetAddr) {\n        _asset = assetAddr;\n        _multiplier = 1;\n    }\n\n    function setAssetAddress(address assetAddr) external {\n        _asset = assetAddr;\n    }\n\n    function setAssetMultiplier(uint multiplier) public {\n        _multiplier = multiplier;\n    }\n\n    // mimic eip-4626\n    function asset() public view returns(address) {\n        return _asset;\n    }\n\n    // mimic eip-4626\n    function previewRedeem(uint256 amount) public view returns(uint) {\n        return amount * _multiplier;\n    }\n}\n"
    },
    "contracts/mock/SimpleOracle.sol": {
      "content": "pragma solidity 0.8.9;\n\nimport { IOracle } from \"../interfaces/IOracle.sol\";\nimport { LoanLib } from \"../utils/LoanLib.sol\";\n\ncontract SimpleOracle is IOracle {\n\n    mapping(address => int) prices;\n\n    constructor(address _supportedToken1, address _supportedToken2) {\n        prices[_supportedToken1] = 1000 * 1e8; // 1000 USD\n        prices[_supportedToken2] = 2000 * 1e8; // 2000 USD\n    }\n\n    function init() external pure returns(bool) {\n        return true;\n    }\n\n    function changePrice(address token, int newPrice) external {\n        prices[token] = newPrice;\n    }\n\n    function getLatestAnswer(address token) external view returns(int256) {\n        // mimic eip4626\n        // (bool success, bytes memory result) = token.call(abi.encodeWithSignature(\"asset()\"));\n        // if(success && result.length > 0) {\n        //     // get the underlying token value (if ERC4626)\n        //     // NB: Share token to underlying ratio might not be 1:1\n        //     token = abi.decode(result, (address));\n        // }\n        require(prices[token] != 0, \"SimpleOracle: unsupported token\");\n        return prices[token];\n    }\n\n    function healthcheck() external pure returns (LoanLib.STATUS status) {\n        return LoanLib.STATUS.ACTIVE;\n    }\n\n    function loan() external pure returns (address) {\n        return address(0);\n    }\n\n}\n"
    },
    "contracts/mock/MockLoan.sol": {
      "content": "pragma solidity 0.8.9;\n\nimport { IEscrow } from \"../interfaces/IEscrow.sol\";\n\ncontract MockLoan {\n\n    uint debtValueUSD;\n    address escrow;\n    address public arbiter;\n\n    constructor(uint _debt) {\n        debtValueUSD = _debt;\n        // console.log(\"arbiter\", msg.sender);\n        arbiter = msg.sender;\n    }\n\n    function setEscrow(address _escrow) public {\n        escrow = _escrow;\n    }\n\n\n    function setArbiter(address _arbiter) public {\n        arbiter = _arbiter;\n    }\n\n    function setDebtValue(uint _debt) external {\n        debtValueUSD = _debt;\n    }\n\n    function liquidate(uint positionId, uint amount, address token, address to) external {\n        IEscrow(escrow).liquidate(amount, token, to);\n    }\n\n    function accrueInterest() external pure returns(uint256) {\n        return 0;\n    }\n\n    function updateOutstandingDebt() external view returns(uint256,uint256) {\n        return (debtValueUSD, 0);\n    }\n\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/modules/credit/SpigotedLoan.t.sol": {
      "content": "\npragma solidity ^0.8.9;\n\nimport { DSTest } from  \"../../../lib/ds-test/src/test.sol\";\nimport { RevenueToken } from \"../../mock/RevenueToken.sol\";\nimport { SimpleOracle } from \"../../mock/SimpleOracle.sol\";\nimport { ZeroEx } from \"../../mock/ZeroEx.sol\";\n\nimport { Spigot } from \"../spigot/Spigot.sol\";\nimport { SpigotedLoan } from './SpigotedLoan.sol';\nimport { LoanLib } from '../../utils/LoanLib.sol';\nimport { ISpigot } from '../../interfaces/ISpigot.sol';\n\n/**\n * @notice\n * @dev - does not test spigot integration e.g. claimEscrow() since that should already be covered in Spigot tests\n *      - these tests would fail if that assumption was wrong anyway\n */\ncontract SpigotedLoanTest is DSTest {\n    ZeroEx dex;\n    SpigotedLoan loan;\n    Spigot spigot;\n\n    RevenueToken creditToken;\n    RevenueToken revenueToken;\n\n    // Named vars for common inputs\n    address constant eth = address(0);\n    address constant revenueContract = address(0xdebf);\n    uint lentAmount = 1 ether;\n    \n    uint128 constant drawnRate = 100;\n    uint128 constant facilityRate = 1;\n    uint constant ttl = 10 days; // allows us t\n    uint8 constant ownerSplit = 10; // 10% of all borrower revenue goes to spigot\n\n    uint constant MAX_INT = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\n    uint constant MAX_REVENUE = MAX_INT / 100;\n\n    // Loan access control vars\n    address private lender;\n    SimpleOracle private oracle;\n    address private arbiter;\n    address private borrower;\n\n    function setUp() public {\n        lender = address(this);\n        arbiter = address(this);\n        borrower = address(this);\n        dex = new ZeroEx();\n        creditToken = new RevenueToken();\n        revenueToken = new RevenueToken();\n\n        oracle = new SimpleOracle(address(revenueToken), address(creditToken));\n        spigot = new Spigot(address(this), borrower, borrower);\n        \n        loan = new SpigotedLoan(address(oracle), arbiter, borrower, address(spigot), address(dex), ttl, ownerSplit);\n        \n        spigot.updateOwner(address(loan));\n\n        loan.init();\n\n        _mintAndApprove();\n        \n        // take out loan\n        loan.addCredit(drawnRate, facilityRate, lentAmount, address(creditToken), lender);\n        loan.addCredit(drawnRate, facilityRate, lentAmount, address(creditToken), lender);\n\n        ISpigot.Setting memory setting = ISpigot.Setting({\n          token: address(revenueToken),\n          ownerSplit: ownerSplit,\n          claimFunction: bytes4(0),\n          transferOwnerFunction: bytes4(\"1234\")\n        });\n        loan.addSpigot(revenueContract, setting);\n        loan.addSpigot(revenueContract, setting);\n\n        // revenue go brrrrrrr\n        spigot.claimRevenue(address(revenueContract), \"\");\n    }\n\n    function _mintAndApprove() public {\n      \n      // seed dex with tokens to buy\n      creditToken.mint(address(dex), MAX_REVENUE);\n      // allow loan to use tokens for depositAndRepay()\n      creditToken.mint(address(this), MAX_REVENUE);\n      creditToken.approve(address(loan), MAX_INT);\n      // allow trades\n      creditToken.approve(address(dex), MAX_INT);\n      \n\n      // tokens to trade\n\n      revenueToken.mint(address(this), MAX_REVENUE);\n      revenueToken.mint(address(loan), MAX_REVENUE);\n      revenueToken.mint(address(dex), MAX_REVENUE);\n      revenueToken.approve(address(dex), MAX_INT);\n\n      // revenue earned\n      revenueToken.mint(address(spigot), MAX_REVENUE);\n      // allow deposits\n      revenueToken.approve(address(loan), MAX_INT);\n\n    }\n\n    // TODO can only remove spigot if repaid or insolvent (propery access for both situations)\n    function testFail_trade_when_no_credit() public {\n      bytes memory tradeData = abi.encodeWithSignature(\n        'trade(address,address,uint256,uint256)',\n        address(revenueToken),\n        address(creditToken),\n        1,\n        1\n      );\n\n      loan.claimAndTrade(address(revenueToken), tradeData);\n    }\n\n\n    function test_can_use_claimed_revenue_to_trade() public {\n      // need to have active position so we can buy asset\n      loan.borrow(loan.ids(0), lentAmount);\n      uint claimable = spigot.getEscrowBalance(address(revenueToken));\n\n      bytes memory tradeData = abi.encodeWithSignature(\n        'trade(address,address,uint256,uint256)',\n        address(revenueToken),\n        address(creditToken),\n        claimable,\n        1\n      );\n      \n      loan.claimAndTrade(address(revenueToken), tradeData);\n\n      // dex balances\n      assertEq(creditToken.balanceOf((address(dex))), MAX_REVENUE - 1);\n      assertEq(revenueToken.balanceOf((address(dex))), MAX_REVENUE + claimable);\n      // loan balances\n      assertEq(creditToken.balanceOf((address(loan))), 1);\n      assertEq(revenueToken.balanceOf((address(loan))), MAX_REVENUE);\n      \n    }\n\n    function testFail_only_unused_revenue_tokens_to_trade() public {\n      // need to have active position so we can buy asset\n      loan.borrow(loan.ids(0), lentAmount);\n\n      uint claimable = spigot.getEscrowBalance(address(revenueToken));\n      \n      // no extra tokens besides claimable\n      assertEq(loan.unused(address(revenueToken)), 0);\n      // Loan already has tokens minted to it that we can try and steal as borrower\n      assertEq(revenueToken.balanceOf(address(loan)), MAX_REVENUE);\n\n      bytes memory tradeData = abi.encodeWithSignature(\n        'trade(address,address,uint256,uint256)',\n        address(revenueToken),\n        address(creditToken),\n        claimable + 1, // try spendnig more tokens than claimed\n        1\n      );\n\n      // No unused tokens so can't get approved\n      // vm.expectRevert(\"ERC20: insufficient allowance\");\n      loan.claimAndTrade(address(revenueToken), tradeData);\n    }\n\n    function testFail_only_unused_credit_tokens_to_trade() public {\n      // need to have active position so we can buy asset\n      loan.borrow(loan.ids(0), lentAmount);\n\n      uint claimable = spigot.getEscrowBalance(address(revenueToken));\n      \n      // no extra tokens\n      assertEq(loan.unused(address(creditToken)), 0);\n      // Loan already has tokens minted to it that we can try and steal as borrower\n      assertEq(creditToken.balanceOf(address(loan)), lentAmount);\n\n      bytes memory tradeData = abi.encodeWithSignature(\n        'trade(address,address,uint256,uint256)',\n        address(revenueToken),\n        address(creditToken),\n        claimable,\n        0 // no credit tokens bought at all\n      );\n\n      // No unused tokens so can't get approved\n      // vm.expectRevert(\"ERC20: insufficient allowance\");\n      loan.claimAndRepay(address(creditToken), tradeData);\n      (,uint p,,,,,) = loan.credits(loan.ids(0));\n      \n      assertEq(p, lentAmount); // nothing repaid\n\n      // vm.expectRevert();\n      loan.useAndRepay(1);\n    }\n\n    function test_increase_unused_revenue(uint buyAmount, uint sellAmount) public {\n      if(buyAmount == 0 || sellAmount == 0) return;\n      if(buyAmount > MAX_REVENUE || sellAmount > MAX_REVENUE) return;\n      \n      // need to have active position so we can buy asset\n      loan.borrow(loan.ids(0), lentAmount);\n\n      uint claimable = spigot.getEscrowBalance(address(revenueToken));\n\n      bytes memory tradeData = abi.encodeWithSignature(\n        'trade(address,address,uint256,uint256)',\n        address(revenueToken),\n        address(creditToken),\n        claimable - 1,\n        lentAmount / 2\n      );\n\n    // make unused tokens available\n      loan.claimAndTrade(address(revenueToken), tradeData);\n\n      assertEq(loan.unused(address(revenueToken)), 1);\n      assertEq(revenueToken.balanceOf(address(loan)), 1);\n      assertEq(revenueToken.balanceOf(address(dex)), MAX_REVENUE + claimable - 1);\n    }\n\n    function test_decrease_unused_revenue(uint buyAmount, uint sellAmount) public {\n            if(buyAmount == 0 || sellAmount == 0) return;\n      if(buyAmount > MAX_REVENUE || sellAmount > MAX_REVENUE) return;\n      \n      // need to have active position so we can buy asset\n      loan.borrow(loan.ids(0), lentAmount);\n\n      uint claimable = spigot.getEscrowBalance(address(revenueToken));\n\n      bytes memory tradeData = abi.encodeWithSignature(\n        'trade(address,address,uint256,uint256)',\n        address(revenueToken),\n        address(creditToken),\n        claimable - 1,\n        lentAmount / 2\n      );\n\n      // make unused tokens available\n      loan.claimAndTrade(address(revenueToken), tradeData);\n\n      assertEq(loan.unused(address(revenueToken)), 1);\n\n      revenueToken.mint(address(spigot), MAX_REVENUE);\n      spigot.claimRevenue(address(revenueContract), \"\");\n\n      bytes memory tradeData2 = abi.encodeWithSignature(\n        'trade(address,address,uint256,uint256)',\n        address(revenueToken),\n        address(creditToken),\n        claimable + 1,\n        1\n      );\n\n      loan.claimAndTrade(address(revenueToken), tradeData2);\n      assertEq(loan.unused(address(revenueToken)), 0);\n    }\n\n    function test_increase_unused_debt(uint buyAmount, uint sellAmount) public {\n      if(buyAmount == 0 || sellAmount == 0) return;\n      if(buyAmount > MAX_REVENUE || sellAmount > MAX_REVENUE) return;\n      \n      // need to have active position so we can buy asset\n      loan.borrow(loan.ids(0), lentAmount);\n\n      uint claimable = spigot.getEscrowBalance(address(revenueToken));\n\n      bytes memory tradeData = abi.encodeWithSignature(\n        'trade(address,address,uint256,uint256)',\n        address(revenueToken),\n        address(creditToken),\n        claimable,\n        lentAmount / 2\n      );\n\n      // make unused tokens available\n      loan.claimAndTrade(address(revenueToken), tradeData);\n\n      assertEq(loan.unused(address(creditToken)), lentAmount / 2);\n    }\n\n    function test_decrease_unused_debt(uint buyAmount, uint sellAmount) public {\n      // effectively the same but want to denot that they can be two separate tests\n      return test_can_repay_with_unused_tokens(buyAmount, sellAmount);\n    }\n\n\n\n    function test_can_repay_with_unused_tokens(uint buyAmount, uint sellAmount) public {\n      // oracle prices not relevant to test\n      if(buyAmount == 0 || sellAmount == 0) return;\n      if(buyAmount > MAX_REVENUE || sellAmount > MAX_REVENUE) return;\n      \n      // need to have active position so we can buy asset\n      loan.borrow(loan.ids(0), lentAmount);\n\n      uint claimable = spigot.getEscrowBalance(address(revenueToken));\n\n      bytes memory tradeData = abi.encodeWithSignature(\n        'trade(address,address,uint256,uint256)',\n        address(revenueToken),\n        address(creditToken),\n        claimable,\n        lentAmount / 2\n      );\n\n      // make unused tokens available\n      loan.claimAndTrade(address(revenueToken), tradeData);\n\n      assertEq(loan.unused(address(creditToken)), lentAmount / 2);\n\n      revenueToken.mint(address(spigot), MAX_REVENUE);\n      spigot.claimRevenue(address(revenueContract), \"\");\n\n      bytes memory repayData = abi.encodeWithSignature(\n        'trade(address,address,uint256,uint256)',\n        address(revenueToken),\n        address(creditToken),\n        claimable,\n        lentAmount / 2\n      );\n\n      loan.claimAndRepay(address(revenueToken), repayData);\n      (,uint p,,,,,) = loan.credits(loan.ids(0));\n\n      assertEq(p, 0);\n      assertEq(loan.unused(address(creditToken)), 0); // used first half to make up for second half missing\n    }\n\n    // trades work\n    function test_can_trade(uint buyAmount, uint sellAmount) public {\n      // oracle prices not relevant to test\n      if(buyAmount == 0 || sellAmount == 0) return;\n      if(buyAmount > MAX_REVENUE || sellAmount > MAX_REVENUE) return;\n      \n      // need to have active position so we can buy asset\n      loan.borrow(loan.ids(0), lentAmount);\n\n      bytes memory tradeData = abi.encodeWithSignature(\n        'trade(address,address,uint256,uint256)',\n        address(revenueToken),\n        address(creditToken),\n        sellAmount,\n        buyAmount\n      );\n\n      uint claimable = spigot.getEscrowBalance(address(revenueToken));\n\n      loan.claimAndTrade(address(revenueToken), tradeData);\n\n      if(claimable > sellAmount) {\n        // we properly test unused token logic elsewhere but still checking here\n        assertEq(claimable - sellAmount, loan.unused(address(revenueToken)));\n      }\n      \n      // dex balances\n      assertEq(creditToken.balanceOf((address(dex))), MAX_REVENUE - buyAmount);\n      assertEq(revenueToken.balanceOf((address(dex))), MAX_REVENUE + sellAmount);\n      \n      // also check credit balances;\n      assertEq(creditToken.balanceOf((address(loan))), buyAmount);\n      assertEq(revenueToken.balanceOf((address(loan))), MAX_REVENUE + claimable - sellAmount);\n    }\n\n    function test_can_trade_and_repay(uint buyAmount, uint sellAmount, uint timespan) public {\n      if(timespan > ttl) return;\n      if(buyAmount == 0 || sellAmount == 0) return;\n      if(buyAmount > MAX_REVENUE || sellAmount > MAX_REVENUE) return;\n\n      loan.borrow(loan.ids(0), lentAmount);\n      \n      // no interest charged because no blocks processed\n      uint256 interest = 0;\n\n      // vm.warp(timespan);\n      // loan.accrueInterest();\n      // (,,uint interest,,,,) = loan.credits(loan.ids(0)) ;\n\n      // oracle prices not relevant to trading test\n      bytes memory tradeData = abi.encodeWithSignature(\n        'trade(address,address,uint256,uint256)',\n        address(revenueToken),\n        address(creditToken),\n        sellAmount,\n        buyAmount\n      );\n\n      uint claimable = spigot.getEscrowBalance(address(revenueToken));\n\n      loan.claimAndRepay(address(revenueToken), tradeData);\n\n      // principal, interest, repaid\n      (,uint p, uint i, uint r,,,) = loan.credits(loan.ids(0));\n\n      // outstanding credit = initial principal + accrued interest - tokens repaid\n      assertEq(p + i, lentAmount + interest - buyAmount);\n\n      if(interest > buyAmount) {\n        // only interest paid\n        assertEq(r, buyAmount);            // paid what interest we could\n        assertEq(i, interest - buyAmount); // interest owed should be reduced by repay amount\n        assertEq(p, lentAmount);             // no change in principal\n      } else {\n        assertEq(p, buyAmount > lentAmount + interest ? 0 : lentAmount - (buyAmount - interest));\n        assertEq(i, 0);                     // all interest repaid\n        assertEq(r, interest);              // all interest repaid\n\n      }\n      emit log_named_uint(\"----  BUY AMOUNT ----\", buyAmount);\n      emit log_named_uint(\"----  SELL AMOUNT ----\", sellAmount);\n\n      uint unusedCreditToken =  buyAmount < lentAmount ? 0 : buyAmount - lentAmount;\n      assertEq(loan.unused(address(creditToken)), unusedCreditToken);\n      assertEq(loan.unused(address(revenueToken)), MAX_REVENUE + claimable - sellAmount);\n    }\n\n\n\n    // check unsused balances. Do so by changing minAmountOut in trade 0\n\n    // Spigot integration tests\n    // Only checking that Loan functions dont fail. Check `Spigot.t.sol` for expected functionality\n\n    function test_can_deposit_and_repay() public {\n      loan.borrow(loan.ids(0), lentAmount);\n      loan.depositAndRepay(lentAmount);\n    }\n\n    function test_update_split() public {\n      loan.updateOwnerSplit(revenueContract);\n    }\n\n    function testFail_release_spigot_while_active() public {\n      assertTrue(loan.releaseSpigot());\n    }\n\n    function test_release_spigot_when_repaid() public {\n      loan.close(loan.ids(0));\n      assertTrue(loan.releaseSpigot());\n\n      // TODO: bad test, will be address(this either way\n      assertEq(spigot.owner(), borrower);\n    }\n\n    function test_cant_sweep_tokens_while_active() public {\n      assertEq(0, loan.sweep(address(creditToken))); // no tokens transfered\n    }\n\n    function test_sweep_tokens_when_repaid() public {\n      assertTrue(loan.close(loan.ids(0)));\n      uint unused = loan.unused(address(creditToken));\n      assertEq(loan.sweep(address(creditToken)), unused);\n    }\n\n    function testFail_update_split_bad_contract() public {\n      loan.updateOwnerSplit(address(0xdead));\n    }\n\n    // TODO force loan into liquidatable to test - updateOwnerSplit, sweep, and releaseSpigot\n}\n"
    },
    "contracts/mock/ZeroEx.sol": {
      "content": "pragma solidity ^0.8.9;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract ZeroEx {\n  constructor () {\n\n  }\n\n\n  function trade(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn,\n    uint256 minAmountOut\n  )\n    external\n    returns(bool)\n  {\n    require(IERC20(tokenIn).transferFrom(msg.sender, address(this), amountIn));\n    require(IERC20(tokenOut).transfer(msg.sender, minAmountOut));\n    return true;\n  }\n}\n"
    },
    "contracts/modules/spigot/Spigot.sol": {
      "content": "pragma solidity 0.8.9;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport {ISpigot} from \"../../interfaces/ISpigot.sol\";\n/**\n * @title Spigot\n * @author Kiba Gateaux\n * @notice Contract allowing Owner to secure revenue streams from a DAO and split payments between them\n * @dev Should be deployed once per loan. Can attach multiple revenue contracts\n */\ncontract Spigot is ISpigot, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    // Constants \n\n    // Maximum numerator for Setting.ownerSplit param\n    uint8 constant MAX_SPLIT =  100;\n    // cap revenue per claim to avoid overflows on multiplication when calculating percentages\n    uint256 constant MAX_REVENUE = type(uint).max / MAX_SPLIT;\n\n    // Stakeholder variables\n    \n    address public owner;\n\n    address public operator;\n\n    address public treasury;\n\n    // Spigot variables\n\n    // Total amount of tokens escrowed by spigot\n    mapping(address => uint256) escrowed; // token  -> amount escrowed\n    //  allowed by operator on all revenue contracts\n    mapping(bytes4 => bool) whitelistedFunctions; // function -> allowed\n    // Configurations for revenue contracts to split\n    mapping(address => Setting) settings; // revenue contract -> settings\n\n    /**\n     *\n     * @dev Configure data for contract owners and initial revenue contracts.\n            Owner/operator/treasury can all be the same address\n     * @param _owner Third party that owns rights to contract's revenue stream\n     * @param _treasury Treasury of DAO that owns contract and receives leftover revenues\n     * @param _operator Operational account of DAO that actively manages contract health\n     *\n     */\n    constructor (\n        address _owner,\n        address _treasury,\n        address _operator\n    ) {\n        owner = _owner;\n        operator = _operator;\n        treasury = _treasury;\n    }\n\n\n\n    // ##########################\n    // #####   Claimoooor   #####\n    // ##########################\n\n    /**\n\n     * @notice - Claim push/pull payments through Spigots.\n                 Calls predefined function in contract settings to claim revenue.\n                 Automatically sends portion to treasury and escrows Owner's share.\n     * @dev - callable by anyone\n     * @param revenueContract Contract with registered settings to claim revenue from\n     * @param data  Transaction data, including function signature, to properly claim revenue on revenueContract\n     * @return claimed -  The amount of tokens claimed from revenueContract and split in payments to `owner` and `treasury`\n    */\n    function claimRevenue(address revenueContract, bytes calldata data)\n        external nonReentrant\n        returns (uint256 claimed)\n    {\n        address token = settings[revenueContract].token;\n        claimed = _claimRevenue(revenueContract, data, token);\n\n        // split revenue stream according to settings\n        uint256 escrowedAmount = claimed * settings[revenueContract].ownerSplit / 100;\n        // update escrowed balance\n        escrowed[token] = escrowed[token] + escrowedAmount;\n        \n        // send non-escrowed tokens to Treasury if non-zero\n        if(claimed > escrowedAmount) {\n            require(_sendOutTokenOrETH(token, treasury, claimed - escrowedAmount));\n        }\n\n        emit ClaimRevenue(token, claimed, escrowedAmount, revenueContract);\n        \n        return claimed;\n    }\n\n\n     function _claimRevenue(address revenueContract, bytes calldata data, address token)\n        internal\n        returns (uint256 claimed)\n    {\n        uint256 existingBalance = _getBalance(token);\n        if(settings[revenueContract].claimFunction == bytes4(0)) {\n            // push payments\n            // claimed = total balance - already accounted for balance\n            claimed = existingBalance - escrowed[token];\n        } else {\n            // pull payments\n            if(bytes4(data) != settings[revenueContract].claimFunction) { revert BadFunction(); }\n            (bool claimSuccess,) = revenueContract.call(data);\n            if(!claimSuccess) { revert ClaimFailed(); }\n            // claimed = total balance - existing balance\n            claimed = _getBalance(token) - existingBalance;\n        }\n\n        if(claimed == 0) { revert NoRevenue(); }\n\n        // cap so uint doesnt overflow in split calculations.\n        // can sweep by \"attaching\" a push payment spigot with same token\n        if(claimed > MAX_REVENUE) claimed = MAX_REVENUE;\n\n        return claimed;\n    }\n\n    /**\n     * @notice - Allows Spigot Owner to claim escrowed tokens from a revenue contract\n     * @dev - callable by `owner`\n     * @param token Revenue token that is being escrowed by spigot\n     * @return claimed -  The amount of tokens claimed from revenue garnish by `owner`\n\n    */\n    function claimEscrow(address token) external nonReentrant returns (uint256 claimed)  {\n        if(msg.sender != owner) { revert CallerAccessDenied(); }\n\n\n        claimed = escrowed[token];\n\n        if(claimed == 0) { revert ClaimFailed(); }\n\n        require(_sendOutTokenOrETH(token, owner, claimed));\n\n        escrowed[token] = 0; // keep 1 in escrow for recurring call gas optimizations?\n\n        emit ClaimEscrow(token, claimed, owner);\n\n        return claimed;\n    }\n\n    /**\n     * @notice - Retrieve amount of tokens tokens escrowed waiting for claim\n     * @param token Revenue token that is being garnished from spigots\n    */\n    function getEscrowBalance(address token) external view returns (uint256) {\n        return escrowed[token];\n    }\n\n\n\n    // ##########################\n    // ##### *ring* *ring*  #####\n    // #####  OPERATOOOR    #####\n    // #####  OPERATOOOR    #####\n    // ##########################\n\n    /**\n     * @notice - Allows Operator to call whitelisted functions on revenue contracts to maintain their product\n     *           while still allowing Spigot Owner to own revenue stream from contract\n     * @dev - callable by `operator`\n     * @param revenueContract - smart contract to call\n     * @param data - tx data, including function signature, to call contract with\n     */\n    function operate(address revenueContract, bytes calldata data) external returns (bool) {\n        if(msg.sender != operator) { revert CallerAccessDenied(); }\n        return _operate(revenueContract, data);\n    }\n\n    /**\n     * @notice - Checks that operation is whitelisted by Spigot Owner and calls revenue contract with supplied data\n     * @param revenueContract - smart contracts to call\n     * @param data - tx data, including function signature, to call contracts with\n     */\n    function _operate(address revenueContract, bytes calldata data) internal nonReentrant returns (bool) {\n        // extract function signature from tx data and check whitelist\n        require(whitelistedFunctions[bytes4(data)], \"Spigot: Unauthorized action\");\n        // cant claim revenue via operate() because that fucks up accounting logic. Owner shouldn't whitelist it anyway but just in case\n        require(settings[revenueContract].claimFunction != bytes4(data), \"Spigot: Unauthorized action\");\n\n        \n        (bool success,) = revenueContract.call(data);\n        require(success, \"Spigot: Operation failed\");\n\n        return true;\n    }\n\n\n\n    // ##########################\n    // #####  Maintainooor  #####\n    // ##########################\n\n    /**\n     * @notice Allow owner to add new revenue stream to spigot\n     * @dev - callable by `owner`\n     * @param revenueContract - smart contract to claim tokens from\n     * @param setting - spigot settings for smart contract   \n     */\n    function addSpigot(address revenueContract, Setting memory setting) external returns (bool) {\n        if(msg.sender != owner) { revert CallerAccessDenied(); }\n        return _addSpigot(revenueContract, setting);\n    }\n\n    /**\n     * @notice Checks  revenue contract doesn't already have spigot\n     *      then registers spigot configuration for revenue contract\n     * @param revenueContract - smart contract to claim tokens from\n     * @param setting - spigot configuration for smart contract   \n     */\n    function _addSpigot(address revenueContract, Setting memory setting) internal returns (bool) {\n        require(revenueContract != address(this));\n        // spigot setting already exists\n        if(settings[revenueContract].transferOwnerFunction != bytes4(0))  {\n          revert BadSetting();\n        }\n        \n        // must set transfer func\n        if(setting.transferOwnerFunction == bytes4(0)) { revert BadSetting(); }\n        require(setting.ownerSplit <= MAX_SPLIT && setting.ownerSplit >= 0, \"Spigot: Invalid split rate\");\n        \n        settings[revenueContract] = setting;\n        emit AddSpigot(revenueContract, setting.token, setting.ownerSplit);\n\n        return true;\n    }\n\n    /**\n\n     * @notice - Change owner of revenue contract from Spigot (this contract) to Operator.\n     *      Sends existing escrow to current Owner.\n     * @dev - callable by `owner`\n     * @param revenueContract - smart contract to transfer ownership of\n     */\n    function removeSpigot(address revenueContract) external returns (bool) {\n        if(msg.sender != owner) { revert CallerAccessDenied(); }\n        \n        address token = settings[revenueContract].token;\n        uint256 claimable = escrowed[token];\n        if(claimable > 0) {\n            require(_sendOutTokenOrETH(token, owner, claimable));\n            emit ClaimEscrow(token, claimable, owner);\n        }\n        \n        (bool success,) = revenueContract.call(\n            abi.encodeWithSelector(\n                settings[revenueContract].transferOwnerFunction,\n                operator    // assume function only takes one param that is new owner address\n            )\n        );\n        require(success);\n\n        delete settings[revenueContract];\n        emit RemoveSpigot(revenueContract, token);\n\n        return true;\n    }\n\n    function updateOwnerSplit(address revenueContract, uint8 ownerSplit) external returns(bool) {\n      if(msg.sender != owner) { revert CallerAccessDenied(); }\n      require(ownerSplit >= 0 && ownerSplit <= MAX_SPLIT, 'Spigot: invalid owner split');\n\n      settings[revenueContract].ownerSplit = ownerSplit;\n      emit UpdateOwnerSplit(revenueContract, ownerSplit);\n      \n      return true;\n    }\n    /**\n\n     * @notice - Update Owner role of Spigot contract.\n     *      New Owner receives revenue stream split and can control Spigot\n     * @dev - callable by `owner`\n     * @param newOwner - Address to give control to\n     */\n    function updateOwner(address newOwner) external returns (bool) {\n        if(msg.sender != owner) { revert CallerAccessDenied(); }\n        require(newOwner != address(0));\n        owner = newOwner;\n        emit UpdateOwner(newOwner);\n        return true;\n    }\n\n    /**\n\n     * @notice - Update Operator role of Spigot contract.\n     *      New Operator can interact with revenue contracts.\n     * @dev - callable by `operator`\n     * @param newOperator - Address to give control to\n     */\n    function updateOperator(address newOperator) external returns (bool) {\n        if(msg.sender != operator) { revert CallerAccessDenied(); }\n        require(newOperator != address(0));\n        operator = newOperator;\n        emit UpdateOperator(newOperator);\n        return true;\n    }\n    \n    /**\n\n     * @notice - Update Treasury role of Spigot contract.\n     *      New Treasury receives revenue stream split\n     * @dev - callable by `treasury`\n     * @param newTreasury - Address to divert funds to\n     */\n    function updateTreasury(address newTreasury) external returns (bool) {\n        if(msg.sender != operator && msg.sender != treasury) {\n          revert CallerAccessDenied();\n        }\n\n        require(newTreasury != address(0));\n        treasury = newTreasury;\n        emit UpdateTreasury(newTreasury);\n        return true;\n    }\n\n    /**\n\n     * @notice - Allows Owner to whitelist function methods across all revenue contracts for Operator to call.\n     *           Can whitelist \"transfer ownership\" functions on revenue contracts\n     *           allowing Spigot to give direct control back to Operator.\n     * @dev - callable by `owner`\n     * @param func - smart contract function signature to whitelist\n     * @param allowed - true/false whether to allow this function to be called by Operator\n     */\n     function updateWhitelistedFunction(bytes4 func, bool allowed) external returns (bool) {\n        if(msg.sender != owner) { revert CallerAccessDenied(); }\n        whitelistedFunctions[func] = allowed;\n        emit UpdateWhitelistFunction(func, allowed);\n        return true;\n    }\n\n    /**\n\n     * @notice - Send ETH or ERC20 token from this contract to an external contract\n     * @param token - address of token to send out. address(0) for raw ETH\n     * @param receiver - address to send tokens to\n     * @param amount - amount of tokens to send\n     */\n    function _sendOutTokenOrETH(address token, address receiver, uint256 amount) internal returns (bool) {\n        if(token!= address(0)) { // ERC20\n            IERC20(token).safeTransfer(receiver, amount);\n        } else { // ETH\n            payable(receiver).transfer(amount);\n        }\n        return true;\n    }\n\n    /**\n\n     * @notice - Helper function to get current balance of this contract for ERC20 or ETH\n     * @param token - address of token to check. address(0) for raw ETH\n     */\n    function _getBalance(address token) internal view returns (uint256) {\n        return token != address(0) ?\n            IERC20(token).balanceOf(address(this)) :\n            address(this).balance;\n    }\n\n    // GETTERS\n\n    function getSetting(address revenueContract)\n        external view\n        returns(address, uint8, bytes4, bytes4)\n    {   \n        return (\n            settings[revenueContract].token,\n            settings[revenueContract].ownerSplit,\n            settings[revenueContract].claimFunction,\n            settings[revenueContract].transferOwnerFunction\n        );\n    }\n\n    receive() external payable {\n        return;\n    }\n\n}\n"
    },
    "contracts/modules/credit/SpigotedLoan.sol": {
      "content": "pragma solidity ^0.8.9;\n\nimport {LineOfCredit} from \"./LineOfCredit.sol\";\nimport {LoanLib} from \"../../utils/LoanLib.sol\";\nimport {CreditLib} from \"../../utils/CreditLib.sol\";\nimport {SpigotedLoanLib} from \"../../utils/SpigotedLoanLib.sol\";\nimport {MutualConsent} from \"../../utils/MutualConsent.sol\";\nimport {ISpigot} from \"../../interfaces/ISpigot.sol\";\nimport {ISpigotedLoan} from \"../../interfaces/ISpigotedLoan.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract SpigotedLoan is ISpigotedLoan, LineOfCredit {\n    using SafeERC20 for IERC20;\n\n    ISpigot public immutable spigot;\n\n    // 0x exchange to trade spigot revenue for credit tokens for\n    address public immutable swapTarget;\n\n    // amount of revenue to take from spigot if loan is healthy\n    uint8 public immutable defaultRevenueSplit;\n\n    // max revenue to take from spigot if loan is in distress\n    uint8 constant MAX_SPLIT = 100;\n\n    // credit tokens we bought from revenue but didn't use to repay loan\n    // needed because Revolver might have same token held in contract as being bought/sold\n    mapping(address => uint256) private unusedTokens;\n\n    /**\n     * @notice - LineofCredit contract with additional functionality for integrating with Spigot and borrower revenue streams to repay loans\n     * @param oracle_ - price oracle to use for getting all token values\n     * @param arbiter_ - neutral party with some special priviliges on behalf of borrower and lender\n     * @param borrower_ - the debitor for all credit positions in this contract\n     * @param swapTarget_ - 0x protocol exchange address to send calldata for trades to\n     * @param ttl_ - the debitor for all credit positions in this contract\n     * @param defaultRevenueSplit_ - the debitor for all credit positions in this contract\n     */\n    constructor(\n        address oracle_,\n        address arbiter_,\n        address borrower_,\n        address spigot_,\n        address swapTarget_,\n        uint256 ttl_,\n        uint8 defaultRevenueSplit_\n    ) LineOfCredit(oracle_, arbiter_, borrower_, ttl_) {\n        require(defaultRevenueSplit_ <= MAX_SPLIT);\n\n        spigot = ISpigot(spigot_);\n        defaultRevenueSplit = defaultRevenueSplit_;\n        swapTarget = swapTarget_;\n    }\n\n    function _init() internal virtual override(LineOfCredit) returns(LoanLib.STATUS) {\n      if(spigot.owner() != address(this)) return LoanLib.STATUS.UNINITIALIZED;\n      return LineOfCredit._init();\n    }\n\n    function unused(address token) external view returns (uint256) {\n        return unusedTokens[token];\n    }\n\n    /**\n\n   * @notice - Claims revenue tokens from Spigot attached to borrowers revenue generating tokens\n               and sells them via 0x protocol to repay credits\n   * @dev    - callable `arbiter` + `borrower`\n               bc they are most incentivized to get best price on assets being sold.\n   * @notice see _repay() for more details\n   * @param claimToken - The revenue token escrowed by Spigot to claim and use to repay credit\n   * @param zeroExTradeData - data generated by 0x API to trade `claimToken` against their exchange contract\n  */\n    function claimAndRepay(address claimToken, bytes calldata zeroExTradeData)\n        external\n        whileBorrowing\n        returns (uint256 repaid)\n    {\n        bytes32 id = ids[0];\n        Credit memory credit = credits[id];\n\n        require(msg.sender == borrower || msg.sender == arbiter);\n        credit =  _accrue(credit, id);\n\n        address targetToken = credit.token;\n\n        uint256 tokensBought = _claimAndTrade(\n            claimToken,\n            targetToken,\n            zeroExTradeData\n        );\n\n\n        repaid = tokensBought + unusedTokens[targetToken];\n        uint256 debt = credit.interestAccrued + credit.principal;\n\n        // cap payment to debt value\n        if (repaid > debt) repaid = debt;\n        // update unused amount based on usage\n        if (repaid > tokensBought) {\n            // using bought + unused to repay loan\n            unusedTokens[targetToken] -= repaid - tokensBought;\n        } else {\n            //  high revenue and bought more than we need\n            unusedTokens[targetToken] += tokensBought - repaid;\n        }\n\n        credits[id] = _repay(credit, id, repaid);\n\n        emit RevenuePayment(claimToken, repaid);\n    }\n\n    function useAndRepay(uint256 amount) external whileBorrowing returns(bool) {\n      require(msg.sender == borrower);\n      bytes32 id = ids[0];\n      Credit memory credit = credits[id];\n      require(amount <= unusedTokens[credit.token]);\n      unusedTokens[credit.token] -= amount;\n\n      credit = _accrue(credit, id);\n      credits[id] = _repay(credit, id, amount);\n\n      return true;\n    }\n\n    /**\n     * @notice allows tokens in escrow to be sold immediately but used to pay down credit later\n     * @dev ensures first token in repayment queue is being bought\n     * @dev    - callable `arbiter` + `borrower`\n     * @param claimToken - the token escrowed in spigot to sell in trade\n     * @param zeroExTradeData - 0x API data to use in trade to sell `claimToken` for `credits[ids[0]]`\n     * returns - amount of credit tokens bought\n     */\n    function claimAndTrade(address claimToken, bytes calldata zeroExTradeData)\n        external\n        whileBorrowing\n        returns (uint256)\n    {\n        require(msg.sender == borrower || msg.sender == arbiter);\n\n        address targetToken = credits[ids[0]].token;\n        uint256 tokensBought = _claimAndTrade(\n          claimToken,\n          targetToken,\n          zeroExTradeData\n        );\n        // add bought tokens to unused balance\n        unusedTokens[targetToken] += tokensBought;\n        return tokensBought;\n    }\n\n    function _claimAndTrade(\n      address claimToken,\n      address targetToken,\n      bytes calldata zeroExTradeData\n    )\n        internal\n        whileBorrowing\n        returns (uint256)\n    {\n        (uint256 tokensBought, uint256 totalUnused) = SpigotedLoanLib.claimAndTrade(\n            claimToken,\n            targetToken,\n            swapTarget,\n            address(spigot),\n            unusedTokens[claimToken],\n            zeroExTradeData\n        );\n        // we dont use revenue after this so can store now\n        unusedTokens[claimToken] = totalUnused;\n        return tokensBought;\n    }\n\n    //  SPIGOT OWNER FUNCTIONS\n\n    /**\n     * @notice changes the revenue split between borrower treasury and lan repayment based on loan health\n     * @dev    - callable `arbiter` + `borrower`\n     * @param revenueContract - spigot to update\n     * @return whether or not split was updated\n     */\n    function updateOwnerSplit(address revenueContract) external returns (bool) {\n        (,uint8 split,  ,bytes4 transferFunc) = spigot.getSetting(revenueContract);\n\n        if(transferFunc == bytes4(0)) { revert NoSpigot(); }\n\n        if(loanStatus == LoanLib.STATUS.ACTIVE && split != defaultRevenueSplit) {\n            // if loan is healthy set split to default take rate\n            return spigot.updateOwnerSplit(revenueContract, defaultRevenueSplit);\n        } else if (loanStatus == LoanLib.STATUS.LIQUIDATABLE && split != MAX_SPLIT) {\n            // if loan is in distress take all revenue to repay loan\n            return spigot.updateOwnerSplit(revenueContract, MAX_SPLIT);\n        }\n\n        return false;\n    }\n\n    /**\n     * @notice - allow Loan to add new revenue streams to reapy credit\n     * @dev    - see Spigot.addSpigot()\n     * @dev    - callable `arbiter` + `borrower`\n     */\n    function addSpigot(\n        address revenueContract,\n        ISpigot.Setting calldata setting\n    )\n        external\n        mutualConsent(arbiter, borrower)\n        returns (bool)\n    {\n        return spigot.addSpigot(revenueContract, setting);\n    }\n\n    /**\n     * @notice - allow borrower to call functions on their protocol to maintain it and keep earning revenue\n     * @dev    - see Spigot.updateWhitelistedFunction()\n     * @dev    - callable `arbiter`\n     */\n    function updateWhitelist(bytes4 func, bool allowed)\n        external\n        returns (bool)\n    {\n        require(msg.sender == arbiter);\n        return spigot.updateWhitelistedFunction(func, allowed);\n    }\n\n    /**\n\n   * @notice -  transfers revenue streams to borrower if repaid or arbiter if liquidatable\n             -  doesnt transfer out if loan is unpaid and/or healthy\n   * @dev    - callable by anyone \n   * @return - whether or not spigot was released\n  */\n    function releaseSpigot() external returns (bool) {\n        if (loanStatus == LoanLib.STATUS.REPAID) {\n           if(!spigot.updateOwner(borrower)) { revert ReleaseSpigotFailed(); }\n            return true;\n        }\n\n        if (loanStatus == LoanLib.STATUS.LIQUIDATABLE) {\n            if(!spigot.updateOwner(arbiter)) { revert ReleaseSpigotFailed(); }\n            return true;\n        }\n\n        return false;\n    }\n\n  /**\n   * @notice - sends unused tokens to borrower if repaid or arbiter if liquidatable\n             -  doesnt send tokens out if loan is unpaid but healthy\n   * @dev    - callable by anyone \n   * @param token - token to take out\n  */\n    function sweep(address token) external returns (uint256) {\n        if (loanStatus == LoanLib.STATUS.REPAID) {\n            return _sweep(borrower, token);\n        }\n        if (loanStatus == LoanLib.STATUS.INSOLVENT) {\n            return _sweep(arbiter, token);\n        }\n\n        return 0;\n    }\n\n    function _sweep(address to, address token) internal returns (uint256 x) {\n        x = unusedTokens[token];\n        if (token == address(0)) {\n            payable(to).transfer(x);\n        } else {\n            IERC20(token).safeTransfer(to, x);\n        }\n        delete unusedTokens[token];\n    }\n\n    // allow trading in ETH\n    receive() external payable {}\n}\n"
    },
    "contracts/interfaces/ISpigot.sol": {
      "content": "interface ISpigot {\n\n    struct Setting {\n        address token;                // token to claim as revenue from contract\n        uint8 ownerSplit;             // x/100 % to Owner, rest to Treasury\n        bytes4 claimFunction;         // function signature on contract to call and claim revenue\n        bytes4 transferOwnerFunction; // function signature on conract to call and transfer ownership \n    }\n\n    // Spigot Events\n\n    event AddSpigot(address indexed revenueContract, address token, uint256 ownerSplit);\n\n    event RemoveSpigot (address indexed revenueContract, address token);\n\n    event UpdateWhitelistFunction(bytes4 indexed func, bool indexed allowed);\n\n    event UpdateOwnerSplit(address indexed revenueContract, uint8 indexed split);\n\n    event ClaimRevenue(address indexed token, uint256 indexed amount, uint256 escrowed, address revenueContract);\n\n    event ClaimEscrow(address indexed token, uint256 indexed amount, address owner);\n\n    // Stakeholder Events\n\n    event UpdateOwner(address indexed newOwner);\n\n    event UpdateOperator(address indexed newOperator);\n\n    event UpdateTreasury(address indexed newTreasury);\n\n    // Errors \n    error BadFunction();\n\n    error ClaimFailed();\n\n    error NoRevenue();\n\n    error CallerAccessDenied();\n    \n    error BadSetting();\n\n\n    function owner() external view returns (address);\n    function treasury() external view returns (address);\n    function operator() external view returns (address);\n    \n    function getSetting(address revenueContract) external view returns (address, uint8, bytes4, bytes4);\n\n    // ops funcs \n\n    function claimRevenue(address revenueContract, bytes calldata data) external returns (uint256 claimed);\n \n    function operate(address revenueContract, bytes calldata data) external returns (bool);\n\n\n    // owner funcs \n    function getEscrowBalance(address token) external view returns (uint256);\n \n    function claimEscrow(address token) external returns (uint256 claimed) ;\n \n    function addSpigot(address revenueContract, Setting memory setting) external returns (bool);\n \n    function removeSpigot(address revenueContract) external returns (bool);\n        \n  \n    // stakeholder funcs \n\n    function updateOwnerSplit(address revenueContract, uint8 ownerSplit) external returns(bool);\n\n    function updateOwner(address newOwner) external returns (bool);\n \n    function updateOperator(address newOperator) external returns (bool);\n \n    function updateTreasury(address newTreasury) external returns (bool);\n \n    function updateWhitelistedFunction(bytes4 func, bool allowed) external returns (bool);\n\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/modules/credit/LineOfCredit.sol": {
      "content": "pragma solidity ^0.8.9;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20}  from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {LoanLib} from \"../../utils/LoanLib.sol\";\nimport {CreditLib} from \"../../utils/CreditLib.sol\";\nimport {CreditListLib} from \"../../utils/CreditListLib.sol\";\nimport {MutualConsent} from \"../../utils/MutualConsent.sol\";\nimport {InterestRateCredit} from \"../interest-rate/InterestRateCredit.sol\";\n\nimport {IOracle} from \"../../interfaces/IOracle.sol\";\nimport {ILineOfCredit} from \"../../interfaces/ILineOfCredit.sol\";\n\ncontract LineOfCredit is ILineOfCredit, MutualConsent {\n    using SafeERC20 for IERC20;\n\n    using CreditListLib for bytes32[];\n\n    uint256 public immutable deadline;\n\n    address public immutable borrower;\n\n    address public immutable arbiter;\n\n    IOracle public immutable oracle;\n\n    InterestRateCredit public immutable interestRate;\n\n    uint256 private count; // amount of open positions. ids.length includes null items\n\n    bytes32[] public ids; // all active positions\n\n    mapping(bytes32 => Credit) public credits; // id -> Credit\n\n    // Loan Financials aggregated accross all existing  Credit\n    LoanLib.STATUS public loanStatus;\n\n    /**\n   * @dev - Loan borrower and proposed lender agree on terms\n            and add it to potential options for borrower to drawdown on\n            Lender and borrower must both call function for MutualConsent to add credit position to Loan\n   * @param oracle_ - price oracle to use for getting all token values\n   * @param arbiter_ - neutral party with some special priviliges on behalf of borrower and lender\n   * @param borrower_ - the debitor for all credit positions in this contract\n   * @param ttl_ - time to live for line of credit contract across all lenders\n  */\n    constructor(\n        address oracle_,\n        address arbiter_,\n        address borrower_,\n        uint256 ttl_\n    ) {\n        oracle = IOracle(oracle_);\n        arbiter = arbiter_;\n        borrower = borrower_;\n        deadline = block.timestamp + ttl_;\n        interestRate = new InterestRateCredit();\n\n        emit DeployLoan(oracle_, arbiter_, borrower_);\n    }\n\n    function init() external virtual returns(LoanLib.STATUS) {\n      require(loanStatus == LoanLib.STATUS.UNINITIALIZED);\n      return _init();\n    }\n\n    function _init() internal virtual returns(LoanLib.STATUS) {\n       // If no modules then loan is immediately active\n      return _updateStatus(LoanLib.STATUS.ACTIVE);\n    }\n\n    ///////////////\n    // MODIFIERS //\n    ///////////////\n\n    modifier whileActive() {\n        if(loanStatus != LoanLib.STATUS.ACTIVE) { revert NotActive(); }\n        _;\n    }\n\n    modifier whileBorrowing() {\n        if(count == 0 || credits[ids[0]].principal == 0) { revert NotBorrowing(); }\n        _;\n    }\n\n    modifier onlyBorrower() {\n        if(msg.sender != borrower) { revert CallerAccessDenied(); }\n        _;\n    }\n\n    /** @notice - mutualConsent but uses position to get lender address instead of passing it in directly */\n    modifier mutualConsentById(address _signerOne, bytes32 id) {\n      if(_mutualConsent(_signerOne, credits[id].lender))  {\n        // Run whatever code needed 2/2 consent\n        _;\n      }\n    }\n\n    function healthcheck() external returns (LoanLib.STATUS) {\n        return LoanLib.updateStatus(loanStatus, _healthcheck());\n    }\n\n    function _healthcheck() internal virtual returns (LoanLib.STATUS) {\n        // if loan is in a final end state then do not run _healthcheck()\n        if (\n            loanStatus == LoanLib.STATUS.REPAID ||\n            loanStatus == LoanLib.STATUS.INSOLVENT\n        ) {\n            return loanStatus;\n        }\n\n        // Liquidate if all lines of credit arent closed by end of term\n        if (block.timestamp >= deadline && count > 0) {\n            emit Default(ids[0]); // can query all defaulted positions offchain once event picked up\n            return LoanLib.STATUS.LIQUIDATABLE;\n        }\n\n        return LoanLib.STATUS.ACTIVE;\n    }\n\n    /**\n  * @notice - Returns total credit obligation of borrower.\n              Aggregated across all lenders.\n              Denominated in USD 1e8.\n  * @dev    - callable by anyone\n  */\n    function updateOutstandingDebt() external override returns (uint256, uint256) {\n        return _updateOutstandingDebt();\n    }\n\n    function _updateOutstandingDebt()\n        internal\n        returns (uint256 principal, uint256 interest)\n    {\n        uint256 len = ids.length;\n        if (len == 0) return (0, 0);\n\n        bytes32 id;\n        address oracle_ = address(oracle);  // gas savings\n        address interestRate_ = address(interestRate);\n        \n        for (uint256 i = 0; i < len;) {\n            id = ids[i];\n            // gas savings. capped to len. inc before early continue\n            unchecked { ++i; }\n\n            // null element in array\n            if(id == bytes32(0)) { continue; }\n\n            (Credit memory c, uint256 _p, uint256 _i) = CreditLib.getOutstandingDebt(\n              credits[id],\n              id,\n              oracle_,\n              interestRate_\n            );\n            // update aggregate usd value\n            principal += _p;\n            interest += _i;\n            // update position data\n            credits[id] = c;\n        }\n    }\n\n    /**\n     * @dev - Loops over all credit positions, calls InterestRate module with position data,\n            then updates `interestAccrued` on position with returned data.\n    */\n    function accrueInterest() external override returns(bool) {\n        uint256 len = ids.length;\n        bytes32 id;\n        for (uint256 i = 0; i < len;) {\n          id = ids[i];\n          Credit memory credit = credits[id];\n          credits[id] = _accrue(credit, id);\n          unchecked { ++i; }\n        }\n        \n        return true;\n    }\n\n    function _accrue(Credit memory credit, bytes32 id) internal returns(Credit memory) {\n      return CreditLib.accrue(credit, id, address(interestRate));\n    }\n\n    /**\n   * @notice        - Loan borrower and proposed lender agree on terms\n                    and add it to potential options for borrower to drawdown on\n                    Lender and borrower must both call function for MutualConsent to add credit position to Loan\n   * @dev           - callable by `lender` and `borrower\n   * @param drate   - interest rate in bps on funds drawndown on LoC\n   * @param frate   - interest rate in bps on all unused funds in LoC\n   * @param amount  - amount of `token` to initially deposit\n   * @param token   - the token to be lent out\n   * @param lender  - address that will manage credit position \n  */\n    function addCredit(\n        uint128 drate,\n        uint128 frate,\n        uint256 amount,\n        address token,\n        address lender\n    )\n        external\n        override\n        whileActive\n        mutualConsent(lender, borrower)\n        returns (bytes32)\n    {\n        IERC20(token).safeTransferFrom(lender, address(this), amount);\n\n        bytes32 id = _createCredit(lender, token, amount);\n\n        require(interestRate.setRate(id, drate, frate));\n        \n        return id;\n    }\n\n    /**\n    * @notice           - Let lender and borrower update rates on a aposition\n    *                   - can set Rates even when LIQUIDATABLE for refinancing\n    * @dev              - include lender in params for cheap gas and consistent API for mutualConsent\n    * @dev              - callable by borrower or any lender\n    * @param id - credit id that we are updating\n    * @param drate      - new drawn rate\n    * @param frate      - new facility rate\n    \n    */\n    function setRates(\n        bytes32 id,\n        uint128 drate,\n        uint128 frate\n    )\n      external\n      override\n      mutualConsentById(borrower, id)\n      returns (bool)\n    {\n        Credit memory credit = credits[id];\n        credits[id] = _accrue(credit, id);\n        require(interestRate.setRate(id, drate, frate));\n        emit SetRates(id, drate, frate);\n        return true;\n    }\n\n\n /**\n    * @notice           - Let lender and borrower increase total capacity of position\n    *                   - can only increase while loan is healthy and ACTIVE.\n    * @dev              - include lender in params for cheap gas and consistent API for mutualConsent\n    * @dev              - callable by borrower    \n    * @param id         - credit id that we are updating\n    * @param amount     - amount to increase deposit / capaciity by\n    */\n    function increaseCredit(bytes32 id, uint256 amount)\n      external\n      override\n      whileActive\n      mutualConsentById(borrower, id)\n      returns (bool)\n    {\n        Credit memory credit = credits[id];\n        credit = _accrue(credit, id);\n        \n        credit.deposit += amount;\n\n        credits[id] = credit;\n\n        IERC20(credit.token).safeTransferFrom(credit.lender, address(this), amount);\n\n        emit IncreaseCredit(id, amount);\n\n        return true;\n    }\n\n    ///////////////\n    // REPAYMENT //\n    ///////////////\n\n    /**\n    * @notice - Transfers enough tokens to repay entire credit position from `borrower` to Loan contract.\n    * @dev - callable by borrower    \n    */\n    function depositAndClose()\n        external\n        override\n        whileBorrowing\n        onlyBorrower\n        returns (bool)\n    {\n        bytes32 id = ids[0];\n        Credit memory credit = credits[id];\n        credit = _accrue(credit, id);\n\n        uint256 totalOwed = credit.principal + credit.interestAccrued;\n\n\n        // borrower deposits remaining balance not already repaid and held in contract\n        IERC20(credit.token).safeTransferFrom(msg.sender, address(this), totalOwed);\n\n        // clear the debt then close and delete position\n        _close(_repay(credit, id, totalOwed), id);\n\n\n        return true;\n    }\n\n    /**\n     * @dev - Transfers token used in credit position from msg.sender to Loan contract.\n     * @dev - callable by anyone\n     * @notice - see _repay() for more details\n     * @param amount - amount of `token` in `id` to pay back\n     */\n    function depositAndRepay(uint256 amount)\n        external\n        override\n        whileBorrowing\n        returns (bool)\n    {\n        bytes32 id = ids[0];\n        Credit memory credit = credits[id];\n        credit = _accrue(credit, id);\n\n        require(amount <= credit.principal + credit.interestAccrued);\n\n        credits[id] = _repay(credit, id, amount);\n\n        IERC20(credit.token).safeTransferFrom(msg.sender, address(this), amount);\n\n        return true;\n    }\n\n    ////////////////////\n    // FUND TRANSFERS //\n    ////////////////////\n\n    /**\n     * @dev - Transfers tokens from Loan to lender.\n     *        Only allowed to withdraw tokens not already lent out (prevents bank run)\n     * @dev - callable by lender on `id`\n     * @param id - the credit position to draw down credit on\n     * @param amount - amount of tokens borrower wants to take out\n     */\n    function borrow(bytes32 id, uint256 amount)\n        external\n        override\n        whileActive\n        onlyBorrower\n        returns (bool)\n    {\n        Credit memory credit = credits[id];\n        credit = _accrue(credit, id);\n\n        if(amount > credit.deposit - credit.principal) { revert NoLiquidity(id) ; }\n\n        credit.principal += amount;\n\n        credits[id] = credit; // save new debt before healthcheck\n\n        if(LoanLib.updateStatus(loanStatus, _healthcheck()) != LoanLib.STATUS.ACTIVE) { \n            revert NotActive();\n        }\n\n        credits[id] = credit;\n\n        IERC20(credit.token).safeTransfer(borrower, amount);\n\n        emit Borrow(id, amount);\n\n        _sortIntoQ(id);\n\n        return true;\n    }\n\n    /**\n     * @dev - Transfers tokens from Loan to lender.\n     *        Only allowed to withdraw tokens not already lent out (prevents bank run)\n     * @dev - callable by lender on `id`\n     * @param id -the credit position to pay down credit on and close\n     * @param amount - amount of tokens lnder would like to withdraw (withdrawn amount may be lower)\n     */\n    function withdraw(bytes32 id, uint256 amount)\n        external\n        override\n        returns (bool)\n    {\n        Credit memory credit = credits[id];\n\n        if(msg.sender != credit.lender) { revert CallerAccessDenied(); }\n\n        credit = _accrue(credit, id);\n\n        credits[id] = CreditLib.withdraw(credit, id, amount);\n\n        IERC20(credit.token).safeTransfer(credit.lender, amount);\n\n        return true;\n    }\n\n    /**\n     * @dev - Deletes credit position preventing any more borrowing.\n     *      - Only callable by borrower or lender for credit position\n     *      - Requires that the credit has already been paid off\n     * @dev - callable by `borrower`\n     * @param id -the credit position to close\n     */\n    function close(bytes32 id) external override returns (bool) {\n      Credit memory credit = credits[id];\n      address b = borrower; // gas savings\n      if(msg.sender != credit.lender && msg.sender != b) {\n          revert CallerAccessDenied();\n        }\n\n        // ensure all money owed is accounted for\n        credit = _accrue(credit, id);\n        uint256 facilityFee = credit.interestAccrued;\n        if(facilityFee > 0) {\n          // only allow repaying interest since they are skipping repayment queue.\n          // If principal still owed, _close() MUST fail\n          IERC20( credit.token).safeTransferFrom(b, address(this), facilityFee);\n          credit = _repay(credit, id, facilityFee);\n        }\n\n        _close(credit, id); // deleted; no need to save to storage\n\n        return true;\n    }\n\n    //////////////////////\n    //  Internal  funcs //\n    //////////////////////\n\n    function _updateStatus(LoanLib.STATUS status_) internal returns(LoanLib.STATUS) {\n      return loanStatus = LoanLib.updateStatus(loanStatus, status_);\n    }\n\n    function _createCredit(\n        address lender,\n        address token,\n        uint256 amount\n    )\n        internal\n        returns (bytes32 id)\n    {\n        id = CreditLib.computePositionId(address(this), lender, token);\n        // MUST not double add position. otherwise we can not _close()\n        if(credits[id].lender != address(0)) { revert PositionExists(); }\n\n        // save credit info\n        credits[id] = CreditLib.create(id, amount, lender, token, address(oracle));\n        ids.push(id); // add lender to end of repayment queue\n        \n        unchecked { ++count; }\n\n        return id;\n    }\n\n  /**\n   * @dev - Reduces `principal` and/or `interestAccrued` on credit position, increases lender's `deposit`.\n            Reduces global USD principal and interestUsd values.\n            Expects checks for conditions of repaying and param sanitizing before calling\n            e.g. early repayment of principal, tokens have actually been paid by borrower, etc.\n   * @param id - credit position struct with all data pertaining to loan\n   * @param amount - amount of token being repaid on credit position\n  */\n    function _repay(Credit memory credit, bytes32 id, uint256 amount)\n        internal\n        returns (Credit memory)\n    { \n        credit = CreditLib.repay(credit, id, amount);\n\n        // if credit fully repaid then remove lender from repayment queue\n        if (credit.principal == 0) ids.stepQ();\n\n        return credit;\n    }\n\n    /**\n     * @notice - checks that credit is fully repaid and remvoes from available lines of credit.\n     * @dev deletes Credit storage. Store any data u might need later in call before _close()\n     */\n    function _close(Credit memory credit, bytes32 id) internal virtual returns (bool) {\n        if(credit.principal > 0) { revert CloseFailedWithPrincipal(); }\n\n        // return the lender's deposit\n        if (credit.deposit > 0) {\n            IERC20(credit.token).safeTransfer(\n                credit.lender,\n                credit.deposit + credit.interestRepaid\n            );\n        }\n\n        delete credits[id]; // gas refunds\n\n        // remove from active list\n        ids.removePosition(id);\n        --count;\n\n        // brick loan contract if all positions closed\n        if (count == 0) { _updateStatus(LoanLib.STATUS.REPAID); }\n\n        emit CloseCreditPosition(id);\n\n        return true;\n    }\n\n    /**\n     * @notice - Insert `p` into the next availble FIFO position in repayment queue\n               - once earliest slot is found, swap places with `p` and position in slot.\n     * @param p - position id that we are trying to find appropriate place for\n     * @return\n     */\n    function _sortIntoQ(bytes32 p) internal returns (bool) {\n        uint256 lastSpot = ids.length - 1;\n        uint256 nextQSpot = lastSpot;\n        bytes32 id;\n        for (uint256 i = 0; i <= lastSpot; i++) {\n            id = ids[i];\n            if (p != id) {\n\n              // Since we aren't constantly trimming array size to to remove empty elements\n              // we should try moving elemtns to front of array in this func to reduce gas costs \n              // only practical if > 10 lenders tho\n              // just inc an vacantSlots and push each id to i - vacantSlot and count = len - vacantSlot\n\n                if (\n                  id == bytes32(0) ||       // deleted element\n                  nextQSpot != lastSpot ||  // position already found. skip to find `p` asap\n                  credits[id].principal > 0 //`id` should be placed before `p` \n                ) continue;\n                nextQSpot = i;              // index of first undrawn line found\n            } else {\n                if(nextQSpot == lastSpot) return true; // nothing to update\n                // swap positions\n                ids[i] = ids[nextQSpot];    // id put into old `p` position\n                ids[nextQSpot] = p;       // p put at target index\n                return true; \n            }\n        }\n    }\n}\n\n"
    },
    "contracts/utils/SpigotedLoanLib.sol": {
      "content": "import { ISpigot } from \"../interfaces/ISpigot.sol\";\nimport { ISpigotedLoan } from \"../interfaces/ISpigotedLoan.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nlibrary SpigotedLoanLib {\n    error TradeFailed();\n    event TradeSpigotRevenue(\n        address indexed revenueToken,\n        uint256 revenueTokenAmount,\n        address indexed debtToken,\n        uint256 indexed debtTokensBought\n    );\n\n    function claimAndTrade(\n        address claimToken,\n        address targetToken,\n        address swapTarget,\n        address spigot,\n        uint256 unused,\n        bytes calldata zeroExTradeData\n    ) \n        external\n        returns(uint256 tokensBought, uint256 totalUnused)\n    {\n        uint256 existingClaimTokens = IERC20(claimToken).balanceOf(address(this));\n        uint256 existingTargetTokens = IERC20(targetToken).balanceOf(address(this));\n\n        uint256 tokensClaimed = ISpigot(spigot).claimEscrow(claimToken);\n\n        if (claimToken == address(0)) {\n            // if claiming/trading eth send as msg.value to dex\n            (bool success, ) = swapTarget.call{value: tokensClaimed}(zeroExTradeData);\n            if(!success) { revert TradeFailed(); }\n        } else {\n            // approve exact amount so other tokens in contract get used e.g. lender funds\n            IERC20(claimToken).approve(swapTarget, unused + tokensClaimed);\n            (bool success, ) = swapTarget.call(zeroExTradeData);\n            if(!success) { revert TradeFailed(); }\n        }\n\n        uint256 targetTokens = IERC20(targetToken).balanceOf(address(this));\n\n        // ideally we could use oracle to calculate # of tokens to receive\n        // but claimToken might not have oracle. targetToken must have oracle\n\n        // underflow revert ensures we have more tokens than we started with\n        tokensBought = targetTokens - existingTargetTokens;\n\n        emit TradeSpigotRevenue(\n            claimToken,\n            tokensClaimed,\n            targetToken,\n            tokensBought\n        );\n\n        uint256 remainingClaimTokens = IERC20(claimToken).balanceOf(address(this));\n        // use reserve revenue to repay debt\n        if(existingClaimTokens > remainingClaimTokens) {\n          uint256 diff = existingClaimTokens - remainingClaimTokens;\n          // used more tokens than we had in unused\n          if(diff > unused) revert TradeFailed(); \n          else totalUnused = unused - diff;\n        } else {\n          // didnt sell all revenue in trade\n          totalUnused = unused + (remainingClaimTokens - existingClaimTokens);\n        }\n\n    }\n}\n"
    },
    "contracts/utils/MutualConsent.sol": {
      "content": "// forked from https://github.com/IndexCoop/index-coop-smart-contracts/blob/master/contracts/lib/MutualConsent.sol\n\npragma solidity 0.8.9;\n\n/**\n * @title MutualConsent\n * @author Set Protocol\n *\n * The MutualConsent contract contains a modifier for handling mutual consents between two parties\n */\nabstract contract MutualConsent {\n    /* ============ State Variables ============ */\n\n    // Mapping of upgradable units and if consent has been initialized by other party\n    mapping(bytes32 => bool) public mutualConsents;\n\n    /* ============ Events ============ */\n\n    event MutualConsentRegistered(\n        bytes32 _consentHash\n    );\n\n    /* ============ Modifiers ============ */\n\n    /**\n    * @notice - allows a function to be called if only two specific stakeholders signoff on the tx data\n    *         - signers can be anyone. only two signers per contract or dynamic signers per tx.\n    */\n    modifier mutualConsent(address _signerOne, address _signerTwo) {\n      if(_mutualConsent(_signerOne, _signerTwo))  {\n        // Run whatever code needed 2/2 consent\n        _;\n      }\n    }\n\n    function _mutualConsent(address _signerOne, address _signerTwo) internal returns(bool) {\n        require(\n            msg.sender == _signerOne || msg.sender == _signerTwo,\n            \"Must be authorized address\"\n        );\n\n        address nonCaller = _getNonCaller(_signerOne, _signerTwo);\n\n        // The consent hash is defined by the hash of the transaction call data and sender of msg,\n        // which uniquely identifies the function, arguments, and sender.\n        bytes32 expectedHash = keccak256(abi.encodePacked(msg.data, nonCaller));\n\n        if (!mutualConsents[expectedHash]) {\n            bytes32 newHash = keccak256(abi.encodePacked(msg.data, msg.sender));\n\n            mutualConsents[newHash] = true;\n\n            emit MutualConsentRegistered(newHash);\n\n            return false;\n        }\n\n        delete mutualConsents[expectedHash];\n\n        return true;\n    }\n\n\n    /* ============ Internal Functions ============ */\n\n    function _getNonCaller(address _signerOne, address _signerTwo) internal view returns(address) {\n        return msg.sender == _signerOne ? _signerTwo : _signerOne;\n    }\n}\n"
    },
    "contracts/interfaces/ISpigotedLoan.sol": {
      "content": "pragma solidity ^0.8.9;\n\nimport {ISpigot} from \"./ISpigot.sol\";\n\ninterface ISpigotedLoan {\n  event RevenuePayment(\n    address indexed token,\n    uint256 indexed amount\n    // dont need to track value like other events because _repay already emits\n    // this event is just semantics/helper to track payments from revenue specifically\n  );\n\n  error NoSpigot();\n  error TradeFailed();\n  error ReleaseSpigotFailed();\n\n  function unused(address token) external returns(uint256);\n\n  function addSpigot(address revenueContract, ISpigot.Setting calldata setting) external returns(bool);\n  function updateOwnerSplit(address revenueContract) external returns(bool);\n  function updateWhitelist(bytes4 func, bool allowed) external returns(bool);\n  function releaseSpigot() external returns(bool);\n\n  function claimAndTrade(\n    address claimToken, \n    bytes calldata zeroExTradeData\n  ) external returns(uint256 tokensBought);\n\n  function claimAndRepay(\n    address token,\n    bytes calldata zeroExTradeData\n  ) external returns(uint256);\n\n  function useAndRepay(uint256 amount) external returns(bool);\n\n  function sweep(address token) external returns(uint256);\n}\n"
    },
    "contracts/utils/CreditListLib.sol": {
      "content": "pragma solidity 0.8.9;\nimport { ILineOfCredit } from \"../interfaces/ILineOfCredit.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\nimport { CreditLib } from \"./CreditLib.sol\";\n/**\n  * @title Debt DAO P2P Loan Library\n  * @author Kiba Gateaux\n  * @notice Core logic and variables to be reused across all Debt DAO Marketplace loans\n */\nlibrary CreditListLib {\n    /**\n     * @dev assumes that `id` is stored only once in `positions` array bc no reason for Loans to store multiple times.\n          This means cleanup on _close() and checks on addDebtPosition are CRITICAL. If `id` is duplicated then the position can't be closed\n     * @param ids - all current active positions on the loan\n     * @param id - hash id that must be removed from active positions\n     * @return newPositions - all active positions on loan after `id` is removed\n     */\n    function removePosition(bytes32[] storage ids, bytes32 id) external returns(bool) {\n      uint256 len = ids.length;\n\n      for(uint i = 0; i < len;) {\n          if(ids[i] == id) {\n              delete ids[i];\n              return true;\n          }\n          unchecked { ++i; }\n      }\n\n      return true;\n    }\n\n    /**\n     * @notice - removes debt position from head of repayement queue and puts it at end of line\n     *         - moves 2nd in line to first\n     * @param ids - all current active positions on the loan\n     * @return newPositions - positions after moving first to last in array\n     */\n    function stepQ(bytes32[] storage ids) external returns(bool) {\n      uint256 len = ids.length ;\n      if(len <= 1) return true; // already ordered\n\n      bytes32 last = ids[0];\n      \n      if(len == 2) {\n        ids[0] = ids[1];\n        ids[1] = last;\n      } else {\n        // move all existing ids up in line\n        for(uint i = 1; i < len; i++) {\n          ids[i - 1] = ids[i]; // could also clean arr here like in _SoritIntoQ\n        }\n        // cycle first el back to end of queue\n        ids[len - 1] = last;\n      }\n      \n      return true;\n    }\n}\n"
    },
    "contracts/modules/interest-rate/InterestRateCredit.sol": {
      "content": "pragma solidity ^0.8.9;\n\nimport {IInterestRateCredit} from \"../../interfaces/IInterestRateCredit.sol\";\n\ncontract InterestRateCredit is IInterestRateCredit {\n    uint256 constant ONE_YEAR = 365.25 days; // one year in sec to use in calculations for rates\n    uint256 constant BASE_DENOMINATOR = 10000; // div 100 for %, div 100 for bps in numerator\n    uint256 constant INTEREST_DENOMINATOR = ONE_YEAR * BASE_DENOMINATOR;\n\n    address immutable loanContract;\n    mapping(bytes32 => Rate) public rates; // id -> lending rates\n\n    /**\n     * @notice Interest contract for line of credit contracts\n     */\n    constructor() {\n        loanContract = msg.sender;\n    }\n\n    ///////////  MODIFIERS  ///////////\n\n    modifier onlyLoanContract() {\n        require(\n            msg.sender == loanContract,\n            \"InterestRateCred: only loan contract.\"\n        );\n        _;\n    }\n\n    ///////////  FUNCTIONS  ///////////\n\n    /**\n     * @dev accrueInterest function for revolver loan\n     * @dev    - callable by `loan`\n     * @param drawnBalance balance of drawn funds\n     * @param facilityBalance balance of facility funds\n     * @return repayBalance amount to be repaid for this interest period\n     *\n     */\n    function accrueInterest(\n        bytes32 id,\n        uint256 drawnBalance,\n        uint256 facilityBalance\n    ) external override onlyLoanContract returns (uint256) {\n        return _accrueInterest(id, drawnBalance, facilityBalance);\n    }\n\n    function _accrueInterest(\n        bytes32 id,\n        uint256 drawnBalance,\n        uint256 facilityBalance\n    ) internal returns (uint256) {\n        Rate memory rate = rates[id];\n        uint256 timespan = block.timestamp - rate.lastAccrued;\n        rates[id].lastAccrued = block.timestamp;\n\n        // r = APR in BPS, x = # tokens, t = time\n        // interest = (r * x * t) / 1yr / 100\n        // facility = deposited - drawn (aka undrawn balance)\n        return (((rate.drawnRate * drawnBalance * timespan) /\n            INTEREST_DENOMINATOR) +\n            ((rate.facilityRate * (facilityBalance - drawnBalance) * timespan) /\n                INTEREST_DENOMINATOR));\n    }\n\n    /**\n     * @notice update interest rates for a position\n     * @dev - Loan contract responsible for calling accrueInterest() before updateInterest() if necessary\n     * @dev    - callable by `loan`\n     */\n    function setRate(\n        bytes32 id,\n        uint128 drawnRate,\n        uint128 facilityRate\n    ) external onlyLoanContract returns (bool) {\n        rates[id] = Rate({\n            drawnRate: drawnRate,\n            facilityRate: facilityRate,\n            lastAccrued: block.timestamp\n        });\n\n        return true;\n    }\n}\n"
    },
    "contracts/modules/spigot/Spigot.t.sol": {
      "content": "pragma solidity 0.8.9;\n\nimport { Spigot } from \"./Spigot.sol\";\nimport { DSTest } from  \"../../../lib/ds-test/src/test.sol\";\nimport { RevenueToken } from \"../../mock/RevenueToken.sol\";\nimport { SimpleRevenueContract } from '../../mock/SimpleRevenueContract.sol';\nimport { ISpigot } from '../../interfaces/ISpigot.sol';\n\ncontract SpigotTest is DSTest {\n    // spigot contracts/configurations to test against\n    RevenueToken private token;\n    address private revenueContract;\n    Spigot private spigot;\n    ISpigot.Setting private settings;\n\n    // Named vars for common inputs\n    address constant eth = address(0);\n    uint256 constant MAX_REVENUE = type(uint).max / 100;\n    // function signatures for mock revenue contract to pass as params to spigot\n    bytes4 constant opsFunc = SimpleRevenueContract.doAnOperationsThing.selector;\n    bytes4 constant transferOwnerFunc = SimpleRevenueContract.transferOwnership.selector;\n    bytes4 constant claimPullPaymentFunc = SimpleRevenueContract.claimPullPayment.selector;\n    bytes4 constant claimPushPaymentFunc = bytes4(0);\n\n    // create dynamic arrays for function args\n    // Mostly unused in tests so convenience for empty array\n    bytes4[] private whitelist;\n    address[] private c;\n    ISpigot.Setting[] private s;\n\n    // Spigot Controller access control vars\n    address private owner;\n    address private operator;\n    address private treasury;\n\n    function setUp() public {\n        owner = address(this);\n        operator = address(this);\n        treasury = address(0xf1c0);\n        token = new RevenueToken();\n\n        _initSpigot(address(token), 100, claimPushPaymentFunc, transferOwnerFunc, whitelist);\n\n        // TODO find some good revenue contracts to mock and deploy\n    }\n\n    /**\n     * @dev Helper function to initialize new Spigots with different params to test functionality\n     */\n    function _initSpigot(\n        address _token,\n        uint8 split,\n        bytes4 claimFunc,\n        bytes4 newOwnerFunc,\n        bytes4[] memory _whitelist\n    ) internal {\n        // deploy new revenue contract with settings\n        revenueContract = address(new SimpleRevenueContract(address(this), address(_token)));\n\n        settings = ISpigot.Setting(_token, split, claimFunc, newOwnerFunc);\n       \n        spigot = new Spigot(owner, treasury, operator);\n        \n        // add spigot for revenue contract \n        require(spigot.addSpigot(revenueContract, settings), \"Failed to add spigot\");\n\n        // give spigot ownership to claim revenue\n        revenueContract.call(abi.encodeWithSelector(newOwnerFunc, address(spigot)));\n    }\n\n\n    // Claiming functions\n\n    function testFail_claimRevenue_PullPaymentNoTokenRevenue() public {\n        _initSpigot(address(token), 100, claimPullPaymentFunc, transferOwnerFunc, whitelist);\n\n        bytes memory claimData = abi.encodeWithSelector(claimPullPaymentFunc);\n        spigot.claimRevenue(revenueContract, claimData);\n    }\n\n    function testFail_claimRevenue_PushPaymentNoTokenRevenue() public {\n        _initSpigot(address(token), 100, claimPushPaymentFunc, transferOwnerFunc, whitelist);\n\n        bytes memory claimData;\n        spigot.claimRevenue(revenueContract, claimData);\n    }\n\n    function testFail_claimRevenue_PushPaymentNoETHRevenue() public {\n        _initSpigot(eth, 100, claimPushPaymentFunc, transferOwnerFunc, whitelist);\n\n        bytes memory claimData;\n        spigot.claimRevenue(revenueContract, claimData);\n    }\n\n    function testFail_claimRevenue_PullPaymentNoETHRevenue() public {\n        _initSpigot(eth, 100, claimPullPaymentFunc, transferOwnerFunc, whitelist);\n\n        bytes memory claimData = abi.encodeWithSelector(claimPullPaymentFunc);\n        spigot.claimRevenue(revenueContract, claimData);\n    }\n\n    /**\n        @dev only need to test claim function on pull payments because push doesnt call revenue contract\n     */\n    function testFail_claimRevenue_NonExistantClaimFunction() public {\n        _initSpigot(address(token), 100, claimPullPaymentFunc, transferOwnerFunc, whitelist);\n\n        bytes memory claimData = abi.encodeWithSelector(bytes4(0xdebfda05));\n        spigot.claimRevenue(revenueContract, claimData);\n    }\n\n    function testFail_claimRevenue_MaliciousClaimFunction() public {\n        _initSpigot(address(token), 100, claimPullPaymentFunc, transferOwnerFunc, whitelist);\n\n        bytes memory claimData = abi.encodeWithSelector(transferOwnerFunc);\n        spigot.claimRevenue(revenueContract, claimData);\n    }\n\n\n    // Claim Revenue - payment split and escrow accounting\n\n    /**\n     * @dev helper func to get max revenue payment claimable in Spigot.\n     *      Prevents uint overflow on owner split calculations\n    */\n    function getMaxRevenue(uint256 totalRevenue) internal pure returns(uint256, uint256) {\n        if(totalRevenue> MAX_REVENUE) return(MAX_REVENUE, totalRevenue - MAX_REVENUE);\n        return (totalRevenue, 0);\n    }\n\n    /**\n     * @dev helper func to check revenue payment streams to `owner` and `treasury` happened and Spigot is accounting properly.\n    */\n    function assertSpigotSplits(address _token, uint256 totalRevenue) internal {\n        (uint256 maxRevenue, uint256 overflow) = getMaxRevenue(totalRevenue);\n        uint256 escrowed = maxRevenue * settings.ownerSplit / 100;\n\n        assertEq(\n            spigot.getEscrowBalance(_token),\n            escrowed,\n            'Invalid escrow amount for spigot revenue'\n        );\n\n        assertEq(\n            _token == eth ?\n                address(spigot).balance :\n                RevenueToken(token).balanceOf(address(spigot)),\n            escrowed + overflow, // revenue over max stays in contract unnaccounted\n            'Spigot balance vs escrow + overflow mismatch'\n        );\n\n        assertEq(\n            _token == eth ?\n                address(treasury).balance :\n                RevenueToken(token).balanceOf(treasury),\n            maxRevenue - escrowed,\n            'Invalid treasury payment amount for spigot revenue'\n        );\n    }\n\n    function test_claimRevenue_pushPaymentToken(uint256 totalRevenue) public {\n        if(totalRevenue == 0) return;\n\n        // send revenue token directly to spigot (push)\n        token.mint(address(spigot), totalRevenue);\n        assertEq(token.balanceOf(address(spigot)), totalRevenue);\n        \n        bytes memory claimData;\n        spigot.claimRevenue(revenueContract, claimData);\n\n        emit log_named_uint(\"total revenue: \", totalRevenue);\n        assertSpigotSplits(address(token), totalRevenue);\n    }\n\n    function test_claimRevenue_pullPaymentToken(uint256 totalRevenue) public {\n        if(totalRevenue == 0) return;\n        _initSpigot(address(token), 100, claimPullPaymentFunc, transferOwnerFunc, whitelist);\n        \n        token.mint(revenueContract, totalRevenue); // send revenue\n        bytes memory claimData = abi.encodeWithSelector(claimPullPaymentFunc);\n        spigot.claimRevenue(revenueContract, claimData);\n        \n        assertSpigotSplits(address(token), totalRevenue);\n        assertEq(token.balanceOf(revenueContract), 0, 'All revenue not siphoned into Spigot');\n    }\n\n    /**\n     * @dev\n     @param totalRevenue - uint96 because that is max ETH in this testing address when dapptools initializes\n     */\n    function test_claimRevenue_pushPaymentETH(uint96 totalRevenue) public {\n        if(totalRevenue == 0) return;\n        _initSpigot(eth, 100, claimPushPaymentFunc, transferOwnerFunc, whitelist);\n\n        payable(address(spigot)).transfer(totalRevenue);\n        assertEq(totalRevenue, address(spigot).balance); // ensure spigot received revenue\n        \n        bytes memory claimData;\n        uint256 revenueClaimed = spigot.claimRevenue(revenueContract, claimData); \n        assertEq(totalRevenue, revenueClaimed, 'Improper revenue amount claimed');\n        emit log_named_uint(\"escrowdAmount\", spigot.getEscrowBalance(eth));\n\n        \n        assertSpigotSplits(eth, totalRevenue);\n    }\n\n    function test_claimRevenue_pullPaymentETH(uint96 totalRevenue) public {\n        if(totalRevenue == 0) return;\n        _initSpigot(eth, 100, claimPullPaymentFunc, transferOwnerFunc, whitelist);\n\n        payable(revenueContract).transfer(totalRevenue);\n\n        bytes memory claimData = abi.encodeWithSelector(claimPullPaymentFunc);\n        assertEq(totalRevenue, spigot.claimRevenue(revenueContract, claimData), 'invalid revenue amount claimed');\n\n        assertSpigotSplits(eth, totalRevenue);\n    }\n\n    \n    // Claim escrow \n\n    function test_claimEscrow_AsOwner(uint256 totalRevenue) public {\n        if(totalRevenue == 0) return;\n        // send revenue and claim it\n        token.mint(address(spigot), totalRevenue);\n        bytes memory claimData;\n        spigot.claimRevenue(revenueContract, claimData);\n        assertSpigotSplits(address(token), totalRevenue);\n\n        uint256 claimed = spigot.claimEscrow(address(token));\n        (uint256 maxRevenue,) = getMaxRevenue(totalRevenue);\n\n        assertEq(maxRevenue * settings.ownerSplit / 100, claimed, \"Invalid escrow claimed\");\n        assertEq(token.balanceOf(owner), claimed, \"Claimed escrow not sent to owner\");\n    }\n\n    function testFail_claimEscrow_AsNonOwner() public {\n        owner = address(0xdebf); // change owner of spigot to deploy\n        _initSpigot(address(token), 100, claimPushPaymentFunc, transferOwnerFunc, whitelist);\n\n        // send revenue and claim it\n        token.mint(address(spigot), 10**10);\n        bytes memory claimData;\n        spigot.claimRevenue(revenueContract, claimData);\n\n        // claim fails\n        spigot.claimEscrow(address(token));\n    }\n\n\n    function testFail_claimEscrow_UnregisteredToken() public {\n        // create new token and send push payment\n        RevenueToken fakeToken = new RevenueToken();\n        fakeToken.mint(address(spigot), 10**10);\n\n        bytes memory claimData;\n        spigot.claimRevenue(revenueContract, claimData);\n        // claim fails because escrowed == 0\n        spigot.claimEscrow(address(fakeToken));\n    }\n\n  \n    \n    // Spigot initialization\n\n    function test_addSpigot_ProperSettings() public {\n        _initSpigot(address(token), 100, claimPullPaymentFunc, transferOwnerFunc, whitelist);\n        (address _token, uint8 _split, bytes4 _claim, bytes4 _transfer) = spigot.getSetting(revenueContract);\n\n        assertEq(settings.token, _token);\n        assertEq(settings.ownerSplit, _split);\n        assertEq(settings.claimFunction, _claim);\n        assertEq(settings.transferOwnerFunction, _transfer);\n    }\n\n    function test_addSpigot_OwnerSplitParam(uint8 split) public {\n        // Split can only be 0-100 for numerator in percent calculation\n        if(split > 100 || split == 0) return;\n        // emit log_named_uint(\"owner split\", split);\n        _initSpigot(address(token), split, claimPullPaymentFunc, transferOwnerFunc, whitelist);\n        // assertEq(spigot.getSetting(revenueContract).ownerSplit, split);\n    }\n\n    function testFail_addSpigot_OwnerSplitParam(uint8 split) public {\n        // Split can only be 0-100 for numerator in percent calculation\n        if(split <= 100) fail();\n\n        _initSpigot(address(token), split, claimPushPaymentFunc, transferOwnerFunc, whitelist);\n    }\n    \n    function testFail_addSpigot_NoTransferFunc() public {\n        _initSpigot(address(token), 100, claimPullPaymentFunc, bytes4(0), whitelist);\n    }\n\n    function test_addSpigot_TransferFuncParam(bytes4 func) public {\n        if(func == claimPushPaymentFunc) return;\n        _initSpigot(address(token), 100, claimPullPaymentFunc, func, whitelist);\n\n        (,,, bytes4 _transfer) = spigot.getSetting(address(revenueContract));\n        assertEq(_transfer, func);\n    }\n\n     function testFail_addSpigot_AsNonOwner() public {\n        owner =  address(0xdebf);\n        \n        _initSpigot(address(token), 100, claimPullPaymentFunc, transferOwnerFunc, whitelist);\n\n        spigot.addSpigot(address(0xdebf), settings);\n    }\n\n    function testFail_addSpigot_ExistingSpigot() public {\n        spigot.addSpigot(revenueContract, settings);\n    }\n\n    function testFail_addSpigot_SpigotAsRevenueContract() public {\n        spigot.addSpigot(address(spigot), settings);\n    }\n\n    // Operate()\n\n    function test_operate_OperatorCanOperate() public {\n        _initSpigot(address(token), 100, claimPullPaymentFunc, transferOwnerFunc, whitelist);\n        // assertEq(true, spigot.updateWhitelistedFunction(opsFunc, true));\n        // assertEq(true, spigot.operate(revenueContract, abi.encodeWithSelector(opsFunc)));\n    }\n\n    function testFail_operate_ClaimRevenueFunction() public {\n        _initSpigot(address(token), 100, claimPullPaymentFunc, transferOwnerFunc, whitelist);\n        \n        bytes memory claimData = abi.encodeWithSelector(claimPullPaymentFunc);\n        spigot.operate(revenueContract, claimData);\n    }\n    \n\n    function testFail_operate_AsNonOperator() public {\n        operator = address(0xdebf);\n        _initSpigot(address(token), 100, claimPullPaymentFunc, transferOwnerFunc, whitelist);\n\n        bytes memory claimData = abi.encodeWithSelector(claimPullPaymentFunc);\n        spigot.operate(revenueContract, claimData);\n    }\n\n\n     function testFail_operate_FailOnNonWhitelistFunc() public {\n        spigot.operate(revenueContract, abi.encodeWithSelector(opsFunc));\n    }\n\n    function test_updateWhitelistedFunction() public {\n        // allow to operate()\n        assertTrue(spigot.updateWhitelistedFunction(opsFunc, true));\n        // // op()\n        assertTrue(spigot.operate(revenueContract, abi.encodeWithSelector(opsFunc)));\n    }\n\n    // Release\n\n    function test_removeSpigot() public {\n        (address token_,,,) = spigot.getSetting(revenueContract);\n        assertEq(address(token), token_);\n\n        spigot.removeSpigot(revenueContract);\n\n        (address token__,,,) = spigot.getSetting(revenueContract);\n        assertEq(address(0), token__);\n    }\n\n\n    function testFail_removeSpigot_AsOperator() public {\n        operator = address(this); // explicitly test operator can't change\n        spigot.updateOwner(address(0xdebf)); // random owner\n        \n        assertEq(spigot.owner(), address(0xdebf));\n        assertEq(spigot.operator(), address(this));\n        \n        spigot.removeSpigot(revenueContract);\n    }\n\n    function testFail_removeSpigot_AsNonOwner() public {\n        spigot.updateOwner(address(0xdebf));\n        \n        assertEq(spigot.owner(), address(0xdebf));\n        \n        spigot.removeSpigot(revenueContract);\n    }\n\n\n    // Access Control Changes\n    function test_updateOwner_AsOwner() public {\n        spigot.updateOwner(address(0xdebf));\n        assertEq(spigot.owner(), address(0xdebf));\n    }\n\n    function test_updateOperator_AsOperator() public {\n        spigot.updateOperator(address(0xdebf));\n        assertEq(spigot.operator(), address(0xdebf));\n    }\n\n    function test_updateTreasury_AsTreasury() public {\n        treasury =  address(this);\n        _initSpigot(address(token), 100, claimPullPaymentFunc, transferOwnerFunc, whitelist);\n\n        spigot.updateTreasury(address(0xdebf));\n        assertEq(spigot.treasury(), address(0xdebf));\n    }\n\n    function test_updateTreasury_AsOperator() public {\n        spigot.updateTreasury(address(0xdebf));\n        assertEq(spigot.treasury(), address(0xdebf));\n    }\n\n    function testFail_updateOwner_AsNonOwner() public {\n        owner =  address(0xdebf);\n        _initSpigot(address(token), 100, claimPullPaymentFunc, transferOwnerFunc, whitelist);\n\n        spigot.updateOwner(address(this));\n    }\n\n    function testFail_updateOwner_NullAddress() public {\n        spigot.updateOwner(address(0));\n    }\n\n    function testFail_updateOperator_AsNonOperator() public {\n        operator =  address(0xdebf);\n        _initSpigot(address(token), 100, claimPullPaymentFunc, transferOwnerFunc, whitelist);\n\n        spigot.updateOperator(address(this));\n    }\n\n    function testFail_updateOperator_NullAddress() public {\n        spigot.updateOperator(address(0));\n    }\n\n    function testFail_updateTreasury_AsNonTreasuryOrOperator() public {\n        treasury =  address(0xdebf);\n        operator =  address(0xdebf);\n\n        _initSpigot(address(token), 100, claimPullPaymentFunc, transferOwnerFunc, whitelist);\n\n        spigot.updateTreasury(address(this));\n    }\n\n    function testFail_updateTreasury_NullAddress() public {\n        treasury = address(this);\n\n        _initSpigot(address(token), 100, claimPullPaymentFunc, transferOwnerFunc, whitelist);\n\n        spigot.updateTreasury(address(0));\n    }\n}\n"
    },
    "contracts/mock/SimpleRevenueContract.sol": {
      "content": "pragma solidity 0.8.9;\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract SimpleRevenueContract {\n    address owner;\n    IERC20 revenueToken;\n\n    constructor(address _owner, address token) {\n        owner = _owner;\n        revenueToken = IERC20(token);\n    }\n\n    function claimPullPayment() external returns(bool) {\n        require(msg.sender == owner, \"Revenue: Only owner can claim\");\n        if(address(revenueToken) != address(0)) {\n            require(revenueToken.transfer(owner, revenueToken.balanceOf(address(this))), \"Revenue: bad transfer\");\n        } else {\n            payable(owner).transfer(address(this).balance);\n        }\n        return true;\n    }\n\n    function sendPushPayment() external returns(bool) {\n        if(address(revenueToken) != address(0)) {\n            require(revenueToken.transfer(owner, revenueToken.balanceOf(address(this))), \"Revenue: bad transfer\");\n        } else {\n            payable(owner).transfer(address(this).balance);\n        }\n        return true;\n    }\n\n    function doAnOperationsThing() external returns(bool)  {\n        require(msg.sender == owner, \"Revenue: Only owner can operate\");\n        return true;\n    }\n\n    function transferOwnership(address newOwner) external returns(bool) {\n        require(msg.sender == owner, \"Revenue: Only owner can transfer\");\n        owner = newOwner;\n        return true;\n    }\n\n    receive() external payable {\n\n    }\n\n}\n"
    },
    "contracts/modules/credit/SecuredLoan.sol": {
      "content": "pragma solidity ^0.8.9;\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { LoanLib } from \"../../utils/LoanLib.sol\";\nimport { EscrowedLoan } from \"./EscrowedLoan.sol\";\nimport { SpigotedLoan } from \"./SpigotedLoan.sol\";\nimport { LineOfCredit } from \"./LineOfCredit.sol\";\n\ncontract SecuredLoan is SpigotedLoan, EscrowedLoan {\n\n    constructor(\n        address oracle_,\n        address arbiter_,\n        address borrower_,\n        address swapTarget_,\n        address spigot_,\n        address escrow_,\n        uint ttl_,\n        uint8 defaultSplit_\n    ) SpigotedLoan(\n        oracle_,\n        arbiter_,\n        borrower_,\n        spigot_,\n        swapTarget_,\n        ttl_,\n        defaultSplit_\n    ) EscrowedLoan(escrow_) {\n\n    }\n\n\n  function init() external override(LineOfCredit) virtual returns(LoanLib.STATUS) {\n    return _updateStatus(_init());\n  }\n\n  function _init() internal override(SpigotedLoan, EscrowedLoan) virtual returns(LoanLib.STATUS) {\n     LoanLib.STATUS s =  LoanLib.STATUS.ACTIVE;\n    \n    if(SpigotedLoan._init() != s || EscrowedLoan._init() != s) {\n      return LoanLib.STATUS.UNINITIALIZED;\n    }\n    \n    return s;\n  }\n\n\n  // Liquidation\n  /**\n   * @notice - Forcefully take collateral from borrower and repay debt for lender\n   * @dev - only called by neutral arbiter party/contract\n   * @dev - `loanStatus` must be LIQUIDATABLE\n   * @dev - callable by `arbiter`\n   * @param positionId -the debt position to pay down debt on\n   * @param amount - amount of `targetToken` expected to be sold off in  _liquidate\n   * @param targetToken - token in escrow that will be sold of to repay position\n   */\n\n  function liquidate(\n    bytes32 positionId,\n    uint256 amount,\n    address targetToken\n  )\n    external\n    returns(uint256)\n  {\n    require(msg.sender == arbiter);\n\n    LoanLib.STATUS status = _updateStatus(_healthcheck());\n    require(status == LoanLib.STATUS.LIQUIDATABLE);\n\n    // send tokens to arbiter for OTC sales\n    return _liquidate(positionId, amount, targetToken, msg.sender);\n  }\n\n  \n    /** @notice checks internal accounting logic for status and if ok, runs modules checks */\n    function _healthcheck() internal override(EscrowedLoan, LineOfCredit) returns(LoanLib.STATUS) {\n      LoanLib.STATUS s = LineOfCredit._healthcheck();\n      if(s != LoanLib.STATUS.ACTIVE) {\n        return s;\n      }\n\n      return EscrowedLoan._healthcheck();\n    }\n\n}\n"
    },
    "contracts/modules/credit/EscrowedLoan.sol": {
      "content": "pragma solidity 0.8.9;\n\nimport { IEscrow } from \"../../interfaces/IEscrow.sol\";\nimport { LoanLib } from \"../../utils/LoanLib.sol\";\nimport { IEscrowedLoan } from \"../../interfaces/IEscrowedLoan.sol\";\n\nabstract contract EscrowedLoan is IEscrowedLoan {\n  // contract holding all collateral for borrower\n  IEscrow immutable public escrow;\n\n  constructor(address _escrow) {\n    escrow = IEscrow(_escrow);\n  }\n\n  function _init() internal virtual returns(LoanLib.STATUS) {\n    require(escrow.loan() == address(this));\n    return LoanLib.STATUS.ACTIVE;\n  }\n\n  /** @dev see BaseLoan._healthcheck */\n  function _healthcheck() virtual internal returns(LoanLib.STATUS) {\n    if(escrow.isLiquidatable()) {\n      return LoanLib.STATUS.LIQUIDATABLE;\n    }\n\n    return LoanLib.STATUS.ACTIVE;\n  }\n\n  /**\n   * @notice sends escrowed tokens to liquidation. \n   *(@dev priviliegad function. Do checks before calling.\n   * @param positionId - position being repaid in liquidation\n   * @param amount - amount of tokens to take from escrow and liquidate\n   * @param targetToken - the token to take from escrow\n   * @param to - the liquidator to send tokens to. could be OTC address or smart contract\n   * @return amount - the total amount of `targetToken` sold to repay credit\n   *  \n   \n  */\n  function _liquidate(\n    bytes32 positionId,\n    uint256 amount,\n    address targetToken,\n    address to\n  )\n    virtual internal\n    returns(uint256)\n  { \n    require(escrow.liquidate(amount, targetToken, to));\n\n    emit Liquidate(positionId, amount, targetToken);\n\n    return amount;\n  }\n}\n\n\n"
    },
    "contracts/interfaces/IEscrowedLoan.sol": {
      "content": "pragma solidity 0.8.9;\n\ninterface IEscrowedLoan {\n  event Liquidate(bytes32 indexed positionId, uint256 indexed amount, address indexed token);\n\n  function liquidate(bytes32 positionId, uint256 amount, address targetToken) external returns(uint256);\n}\n"
    },
    "contracts/modules/credit/SecuredLoan.t.sol": {
      "content": "pragma solidity 0.8.9;\n\nimport { Escrow } from \"../escrow/Escrow.sol\";\nimport { Spigot } from \"../spigot/Spigot.sol\";\nimport { DSTest } from  \"../../../lib/ds-test/src/test.sol\";\nimport { LoanLib } from \"../../utils/LoanLib.sol\";\nimport { RevenueToken } from \"../../mock/RevenueToken.sol\";\nimport { SimpleOracle } from \"../../mock/SimpleOracle.sol\";\nimport { SecuredLoan } from \"./SecuredLoan.sol\";\n\ncontract LoanTest is DSTest {\n\n    Escrow escrow;\n    RevenueToken supportedToken1;\n    RevenueToken supportedToken2;\n    RevenueToken unsupportedToken;\n    SimpleOracle oracle;\n    SecuredLoan loan;\n    uint mintAmount = 100 ether;\n    uint MAX_INT = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\n    uint minCollateralRatio = 1 ether; // 100%\n    uint128 drawnRate = 100;\n    uint128 facilityRate = 1;\n\n    address borrower;\n    address arbiter;\n    address lender;\n\n    function setUp() public {\n        borrower = address(this);\n        lender = address(this);\n        arbiter = address(this);\n        supportedToken1 = new RevenueToken();\n        supportedToken2 = new RevenueToken();\n        unsupportedToken = new RevenueToken();\n\n        Spigot spigot = new Spigot(address(this), borrower, borrower);\n        oracle = new SimpleOracle(address(supportedToken1), address(supportedToken2));\n        escrow = new Escrow(minCollateralRatio, address(oracle),address(this), borrower);\n\n        loan = new SecuredLoan(\n          address(oracle),\n          arbiter,\n          borrower,\n          address(0),\n          address(spigot),\n          address(escrow),\n          150 days,\n          0\n        );\n        \n        escrow.updateLoan(address(loan));\n        spigot.updateOwner(address(loan));\n        loan.init();\n\n        escrow.enableCollateral( address(supportedToken1));\n        escrow.enableCollateral( address(supportedToken2));\n        _mintAndApprove();\n        escrow.addCollateral(1 ether, address(supportedToken2));\n    }\n\n    function _mintAndApprove() internal {\n        supportedToken1.mint(borrower, mintAmount);\n        supportedToken1.approve(address(escrow), MAX_INT);\n        supportedToken1.approve(address(loan), MAX_INT);\n\n        supportedToken2.mint(borrower, mintAmount);\n        supportedToken2.approve(address(escrow), MAX_INT);\n        supportedToken2.approve(address(loan), MAX_INT);\n\n        unsupportedToken.mint(borrower, mintAmount);\n        unsupportedToken.approve(address(escrow), MAX_INT);\n        unsupportedToken.approve(address(loan), MAX_INT);\n    }\n\n    function test_can_liquidate_escrow_if_cratio_below_min() public {\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n        uint balanceOfEscrow = supportedToken2.balanceOf(address(escrow));\n        uint balanceOfArbiter = supportedToken2.balanceOf(arbiter);\n        bytes32 id = loan.ids(0);\n        loan.borrow(id, 1 ether);\n        (uint p,) = loan.updateOutstandingDebt();\n        assertGt(p, 0);\n        oracle.changePrice(address(supportedToken2), 1);\n        loan.liquidate(id, 1 ether, address(supportedToken2));\n        assertEq(balanceOfEscrow, supportedToken1.balanceOf(address(escrow)) + 1 ether, \"Escrow balance should have increased by 1e18\");\n        assertEq(balanceOfArbiter, supportedToken2.balanceOf(arbiter) - 1 ether, \"Arbiter balance should have decreased by 1e18\");\n    }\n\n    function test_health_becomes_liquidatable_if_cratio_below_min() public {\n        assert(loan.healthcheck() == LoanLib.STATUS.ACTIVE);\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n        bytes32 id = loan.ids(0);\n        loan.borrow(id, 1 ether);\n        oracle.changePrice(address(supportedToken2), 1);\n        assert(loan.healthcheck() == LoanLib.STATUS.LIQUIDATABLE);\n    }\n\n    function test_loan_is_active_on_deployment() public {\n        assert(loan.healthcheck() == LoanLib.STATUS.ACTIVE);\n    }\n\n    function test_can_add_credit_position() public {\n        assertEq(supportedToken1.balanceOf(address(loan)), 0, \"Loan balance should be 0\");\n        assertEq(supportedToken1.balanceOf(address(this)), mintAmount, \"Contract should have initial mint balance\");\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n        bytes32 id = loan.ids(0);\n        assert(id != bytes32(0));\n        assertEq(supportedToken1.balanceOf(address(loan)), 1 ether, \"Loan balance should be 1e18\");\n        assertEq(supportedToken1.balanceOf(address(this)), mintAmount - 1 ether, \"Contract should have initial mint balance minus 1e18\");\n    }\n\n    function test_can_borrow() public {\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n        assertEq(supportedToken1.balanceOf(address(this)), mintAmount - 1 ether, \"Contract should have initial mint balance minus 1e18\");\n        bytes32 id = loan.ids(0);\n        assertEq(supportedToken1.balanceOf(address(loan)), 1 ether, \"Loan balance should be 1e18\");\n        loan.borrow(id, 1 ether);\n        assertEq(supportedToken1.balanceOf(address(loan)), 0, \"Loan balance should be 0\");\n        assertEq(supportedToken1.balanceOf(address(this)), mintAmount, \"Contract should have initial mint balance\");\n        int prc = oracle.getLatestAnswer(address(supportedToken1));\n        uint tokenPriceOneUnit = prc < 0 ? 0 : uint(prc);\n        (uint p,) = loan.updateOutstandingDebt();\n        assertEq(p, tokenPriceOneUnit, \"Principal should be set as one full unit price in USD\");\n    }\n\n    function test_can_manually_close_if_no_outstanding_credit() public {\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n        bytes32 id = loan.ids(0);\n        loan.borrow(id, 1 ether);\n        loan.depositAndRepay(1 ether);\n        (uint p, uint i) = loan.updateOutstandingDebt();\n        assertEq(p + i, 0, \"Loan outstanding credit should be 0\");\n        loan.close(id);\n    }\n\n    function test_can_repay_loan() public {\n        int prc = oracle.getLatestAnswer(address(supportedToken1));\n        uint tokenPriceOneUnit = prc < 0 ? 0 : uint(prc);\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n        bytes32 id = loan.ids(0);\n        loan.borrow(id, 1 ether);\n        (uint p, uint i) = loan.updateOutstandingDebt();\n        assertEq(p + i, tokenPriceOneUnit, \"Loan outstanding credit should be set as one full unit price in USD\");\n        assertEq(p, tokenPriceOneUnit, \"Principal should be set as one full unit price in USD\");\n        assertEq(i, 0, \"No interest should have been accrued\");\n        loan.depositAndRepay(1 ether);\n        (uint p2, uint i2) = loan.updateOutstandingDebt();\n        assertEq(p2 + i2, 0, \"Loan outstanding credit should be 0\");\n        assertEq(p2, 0, \"Principle should be 0\");\n        assertEq(i2, 0, \"No interest should have been accrued\");\n    }\n\n    function test_can_repay_part_of_loan() public {\n        int prc = oracle.getLatestAnswer(address(supportedToken1));\n        uint tokenPriceOneUnit = prc < 0 ? 0 : uint(prc);\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n        bytes32 id = loan.ids(0);\n        loan.borrow(id, 1 ether);\n        loan.depositAndRepay(0.5 ether);\n        (uint p, uint i) = loan.updateOutstandingDebt();\n        assertEq(p + i, tokenPriceOneUnit / 2, \"Loan outstanding credit should be set as half of one full unit price in USD\");\n        assertEq(p, tokenPriceOneUnit / 2, \"Principal should be set as half of one full unit price in USD\");\n        assertEq(i, 0, \"No interest should have been accrued\");\n    }\n\n    function test_can_repay_one_credit_and_keep_another() public {\n        int prc = oracle.getLatestAnswer(address(supportedToken2));\n        uint tokenPriceOneUnit = prc < 0 ? 0 : uint(prc);\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n        bytes32 id = loan.ids(0);\n        loan.borrow(id, 1 ether);\n        loan.depositAndRepay(1 ether);\n        \n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken2), lender);\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken2), lender);\n        bytes32 id2 = loan.ids(1);\n        loan.borrow(id2, 1 ether);\n        (uint p, uint i) = loan.updateOutstandingDebt();\n        assertEq(p + i, tokenPriceOneUnit, \"Loan outstanding credit should be set as one full unit price in USD\");\n        assertEq(p, tokenPriceOneUnit, \"Principal should be set as one full unit price in USD\");\n        assertEq(i, 0, \"No interest should have been accrued\");\n    }\n\n\n    function setupQueueTest(uint amount) internal returns (address[] memory) {\n      address[] memory tokens = new address[](amount);\n      // generate token for simulating different repayment flows\n      for(uint i = 0; i < amount; i++) {\n        RevenueToken token = new RevenueToken();\n        tokens[i] = address(token);\n\n        token.mint(address(this), mintAmount);\n        token.approve(address(loan), mintAmount);\n        token.approve(address(escrow), mintAmount);\n        oracle.changePrice(address(token), 1 ether);\n        escrow.enableCollateral(address(token));\n\n        // add collateral for each token so we can borrow it during tests\n        escrow.addCollateral(1 ether, address(token));\n      }\n      \n      return tokens;\n    }\n\n    function test_positions_move_in_queue_of_2() public {\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n        bytes32 id = loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken2), lender);\n        bytes32 id2 = loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken2), lender);\n\n        assertEq(loan.ids(0), id);\n        assertEq(loan.ids(1), id2);\n\n        loan.borrow(id2, 1 ether);\n        \n        assertEq(loan.ids(0), id2);\n        assertEq(loan.ids(1), id);\n\n        loan.depositAndClose();\n\n        assertEq(loan.ids(0), id);\n    }\n\n    function test_positions_move_in_queue_of_4_random_active_line() public {\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n        bytes32 id = loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken2), lender);\n        bytes32 id2 = loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken2), lender);\n\n        // create 3rd token to fully test array sorting\n        address[] memory tokens = setupQueueTest(2);\n        address token3 = tokens[0];\n        address token4 = tokens[1];\n\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(token3), lender);\n        bytes32 id3 = loan.addCredit(drawnRate, facilityRate, 1 ether, address(token3), lender);\n        \n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(token4), lender);\n        bytes32 id4 = loan.addCredit(drawnRate, facilityRate, 1 ether, address(token4), lender);\n\n        assertEq(loan.ids(0), id);\n        assertEq(loan.ids(1), id2);\n        assertEq(loan.ids(2), id3);\n        assertEq(loan.ids(3), id4);\n\n        loan.borrow(id2, 1 ether);\n        \n        assertEq(loan.ids(0), id2);\n        assertEq(loan.ids(1), id);\n        assertEq(loan.ids(2), id3);\n        assertEq(loan.ids(3), id4);\n        \n        loan.borrow(id4, 1 ether);\n\n        assertEq(loan.ids(0), id2);\n        assertEq(loan.ids(1), id4);\n        assertEq(loan.ids(2), id3);\n        assertEq(loan.ids(3), id); // id switches with id4, not just pushed one step back in queue\n\n        loan.depositAndClose();\n\n        assertEq(loan.ids(0), id4);\n        assertEq(loan.ids(1), id3);\n        assertEq(loan.ids(2), id);\n    }\n\n\n\n    // check that only borrowing from the last possible id will still sort queue properly\n    // testing for bug in code where _i is initialized at 0 and never gets updated causing position to go to first position in repayment queue\n    function test_positions_move_in_queue_of_4_only_last() public {\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n        bytes32 id = loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken2), lender);\n        bytes32 id2 = loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken2), lender);\n\n        address[] memory tokens = setupQueueTest(2);\n        address token3 = tokens[0];\n        address token4 = tokens[1];\n\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(token3), lender);\n        bytes32 id3 = loan.addCredit(drawnRate, facilityRate, 1 ether, address(token3), lender);\n        \n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(token4), lender);\n        bytes32 id4 = loan.addCredit(drawnRate, facilityRate, 1 ether, address(token4), lender);\n\n        assertEq(loan.ids(0), id);\n        assertEq(loan.ids(1), id2);\n        assertEq(loan.ids(2), id3);\n        assertEq(loan.ids(3), id4);\n\n        loan.borrow(id4, 1 ether);\n        \n        assertEq(loan.ids(0), id4);\n        assertEq(loan.ids(1), id2);\n        assertEq(loan.ids(2), id3);\n        assertEq(loan.ids(3), id);\n        \n        loan.borrow(id, 1 ether);\n\n        assertEq(loan.ids(0), id4);\n        assertEq(loan.ids(1), id);\n        assertEq(loan.ids(2), id3);\n        assertEq(loan.ids(3), id2); // id switches with id4, not just pushed one step back in queue\n\n        loan.depositAndRepay(1 wei);\n\n        assertEq(loan.ids(0), id4);\n        assertEq(loan.ids(1), id);\n        assertEq(loan.ids(2), id3);\n        assertEq(loan.ids(3), id2);\n\n        loan.depositAndClose();\n\n        assertEq(loan.ids(0), id);\n        assertEq(loan.ids(1), id3);\n        assertEq(loan.ids(2), id2);\n    }\n\n    function test_can_deposit_and_close_position() public {\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n        bytes32 id = loan.ids(0);\n        assertEq(supportedToken1.balanceOf(address(loan)), 1 ether, \"Loan balance should be 1e18\");\n        loan.borrow(id, 1 ether);\n        assertEq(supportedToken1.balanceOf(address(loan)), 0, \"Loan balance should be 0\");\n        assertEq(supportedToken1.balanceOf(address(this)), mintAmount, \"Contract should have initial mint balance\");\n        loan.depositAndClose();\n        assertEq(supportedToken1.balanceOf(address(loan)), 0, \"Tokens should be sent back to lender\");\n        (uint p, uint i) = loan.updateOutstandingDebt();\n        assertEq(p + i, 0, \"Loan outstanding credit should be 0\");\n    }\n\n    function test_can_withdraw_from_position() public {\n        assertEq(supportedToken1.balanceOf(address(this)), mintAmount, \"Contract should have initial mint balance\");\n        loan.addCredit(drawnRate, facilityRate, 0.5 ether, address(supportedToken1), lender);\n        loan.addCredit(drawnRate, facilityRate, 0.5 ether, address(supportedToken1), lender);\n        bytes32 id = loan.ids(0);\n        assertEq(supportedToken1.balanceOf(address(this)), mintAmount - 0.5 ether, \"Contract should have initial mint balance - 1e18 / 2\");\n        assertEq(supportedToken1.balanceOf(address(loan)), 0.5 ether, \"Loan balance should be 1e18 / 2\");\n        loan.withdraw(id, 0.1 ether);\n        assertEq(supportedToken1.balanceOf(address(loan)), 0.4 ether, \"Loan balance should be 1e18 * 0.4\");\n        assertEq(supportedToken1.balanceOf(address(this)), mintAmount - 0.4 ether, \"Contract should have initial mint balance - 1e18 * 0.4\");\n    }\n\n    function test_return_lender_funds_on_deposit_and_close() public {\n      assertEq(supportedToken1.balanceOf(address(loan)), 0, \"Loan balance should be 0\");\n      assertEq(supportedToken1.balanceOf(address(this)), mintAmount, \"Contract should have initial mint balance\");\n      \n      loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n      loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n\n      bytes32 id = loan.ids(0);\n      \n      assert(id != bytes32(0));\n\n      assertEq(supportedToken1.balanceOf(address(this)), mintAmount - 1 ether, \"Contract should have initial balance less lent amount\");\n\n      // test depsoitAndClose()\n      loan.borrow(id, 1 ether);\n      assertEq(supportedToken1.balanceOf(address(this)), mintAmount, \"Contract should have initial balance after depositAndClose\");\n      loan.depositAndClose();\n      assertEq(supportedToken1.balanceOf(address(this)), mintAmount, \"Contract should have initial balance after depositAndClose\");\n      assertEq(supportedToken1.balanceOf(address(loan)), 0, \"Loan should not have tokens\");\n      \n      assertEq(uint(loan.loanStatus()), uint(LoanLib.STATUS.REPAID), \"Loan not repaid\");\n    }\n\n    function test_return_lender_funds_on_close() public {\n        assertEq(supportedToken1.balanceOf(address(loan)), 0, \"Loan balance should be 0\");\n        assertEq(supportedToken1.balanceOf(address(this)), mintAmount, \"Contract should have initial mint balance\");\n        \n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n\n        bytes32 id = loan.ids(0);\n        assert(id != bytes32(0));\n\n        assertEq(supportedToken1.balanceOf(address(this)), mintAmount - 1 ether, \"Contract should have initial balance less lent amount\");\n\n        loan.borrow(id, 1 ether);\n        assertEq(supportedToken1.balanceOf(address(this)), mintAmount, \"Contract should have initial balance after depositAndClose\");\n        loan.depositAndRepay(1 ether);\n        assertEq(supportedToken1.balanceOf(address(this)), mintAmount - 1 ether, \"Contract should have initial balance after depositAndClose\");\n        loan.close(id);\n\n        assertEq(supportedToken1.balanceOf(address(this)), mintAmount, \"Contract should have initial balance after close\");\n        assertEq(supportedToken1.balanceOf(address(loan)), 0, \"Loan should not have tokens\");\n        assertEq(uint(loan.loanStatus()), uint(LoanLib.STATUS.REPAID), \"Loan not repaid\");\n    }\n\n    function test_accrues_and_repays_facility_fee_on_close() public {\n        assertEq(supportedToken1.balanceOf(address(loan)), 0, \"Loan balance should be 0\");\n        assertEq(supportedToken1.balanceOf(address(this)), mintAmount, \"Contract should have initial mint balance\");\n        \n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n\n        bytes32 id = loan.ids(0);\n\n        assertEq(supportedToken1.balanceOf(address(this)), mintAmount - 1 ether, \"Contract should have initial balance less lent amount\");\n\n        loan.borrow(id, 1 ether);\n        assertEq(supportedToken1.balanceOf(address(this)), mintAmount, \"Contract should have initial balance after depositAndClose\");\n        loan.depositAndRepay(1 ether);\n        assertEq(supportedToken1.balanceOf(address(this)), mintAmount - 1 ether, \"Contract should have initial balance after depositAndClose\");\n\n        loan.close(id);\n\n        assertEq(supportedToken1.balanceOf(address(this)), mintAmount, \"Contract should have initial balance after close\");\n        assertEq(supportedToken1.balanceOf(address(loan)), 0, \"Loan should not have tokens\");\n        assertEq(uint(loan.loanStatus()), uint(LoanLib.STATUS.REPAID), \"Loan not repaid\");\n    }\n\n    function test_loan_status_changes_to_liquidatable() public {\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n        bytes32 id = loan.ids(0);\n        loan.borrow(id, 1 ether);\n        oracle.changePrice(address(supportedToken2), 1);\n        assert(loan.healthcheck() == LoanLib.STATUS.LIQUIDATABLE);\n    }\n\n    function test_cannot_open_credit_position_if_only_one_party_agrees() public {\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n        assertEq(supportedToken1.balanceOf(address(loan)), 0, \"Loan balance should be 0\");\n    }\n\n    function testFail_cannot_open_credit_position_if_only_one_party_agrees() public {\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n        loan.ids(0);\n    }\n\n    function testFail_cannot_borrow_from_credit_position_if_under_collateralised() public {\n        loan.addCredit(drawnRate, facilityRate, 100 ether, address(supportedToken1), lender);\n        loan.addCredit(drawnRate, facilityRate, 100 ether, address(supportedToken1), lender);\n        bytes32 id = loan.ids(0);\n        loan.borrow(id, 100 ether);\n    }\n\n    function testFail_cannot_withdraw_if_all_loaned_out() public {\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n        bytes32 id = loan.ids(0);\n        loan.borrow(id, 1 ether);\n        loan.withdraw(id, 0.1 ether);\n    }\n\n    function testFail_cannot_borrow_more_than_position() public {\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n        bytes32 id = loan.ids(0);\n        loan.borrow(id, 100 ether);\n    }\n\n    function testFail_cannot_create_credit_with_tokens_unsupported_by_oracle() public {\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(unsupportedToken), lender);\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(unsupportedToken), lender);\n    }\n\n    function testFail_cannot_borrow_if_not_active() public {\n        assert(loan.healthcheck() == LoanLib.STATUS.ACTIVE);\n        loan.addCredit(drawnRate, facilityRate, 0.1 ether, address(supportedToken1), lender);\n        loan.addCredit(drawnRate, facilityRate, 0.1 ether, address(supportedToken1), lender);\n        bytes32 id = loan.ids(0);\n        loan.borrow(id, 0.1 ether);\n        oracle.changePrice(address(supportedToken2), 1);\n        assert(loan.healthcheck() == LoanLib.STATUS.LIQUIDATABLE);\n        loan.borrow(id, 0.9 ether);\n    }\n\n    function testFail_cannot_borrow_against_closed_position() public {\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n        bytes32 id = loan.ids(0);\n        loan.borrow(id, 1 ether);\n        loan.depositAndClose();\n        loan.borrow(id, 1 ether);\n    }\n\n    function testFail_cannot_manually_close_if_credit_outstanding() public {\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n        bytes32 id = loan.ids(0);\n        loan.borrow(id, 0.1 ether);\n        loan.close(id);\n    }\n\n    function testFail_cannot_liquidate_escrow_if_cratio_above_min() public {\n        loan.liquidate(0, 1 ether, address(supportedToken1));\n    }\n\n    function testFail_health_is_not_liquidatable_if_cratio_above_min() public {\n        assert(loan.healthcheck() == LoanLib.STATUS.LIQUIDATABLE);\n    }\n\n    function test_increase_credit_limit_with_consent() public {\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n        bytes32 id = loan.ids(0);\n        (uint d,,,,,,) = loan.credits(id);\n        \n\n        loan.increaseCredit(id, 1 ether);\n        loan.increaseCredit(id, 1 ether);\n        (uint d2,,,,,,) = loan.credits(id);\n        assertEq(d2 - d, 1 ether);\n    }\n\n    // function test_cannot_increase_credit_limit_without_consent() public {\n    //     // TODO need a way to fake `lender` so mutualConsentById will fail\n    //     loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n    //     loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n    //     bytes32 id = loan.ids(0);\n    //     (uint d,,,,,,) = loan.credits(id);\n        \n\n    //     // try to mock lender address as someone else\n    //     loan.increaseCredit(id, 1 ether);\n    //     loan.increaseCredit(id, 1 ether);\n    //     (uint d2,,,,,,) = loan.credits(id); \n    //     assertEq(d2, d);\n    // }\n\n    function test_can_update_rates_with_consent() public {\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n        loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n        bytes32 id = loan.ids(0);\n      \n\n        loan.setRates(id, uint128(1 ether), uint128(1 ether));\n        loan.setRates(id, uint128(1 ether), uint128(1 ether));\n        (uint128 drate, uint128 frate,) = loan.interestRate().rates(id);\n        assertEq(drate, uint128(1 ether));\n        assertEq(frate, uint128(1 ether));\n        assertGt(frate, facilityRate);\n        assertGt(drate, drawnRate);\n    }\n\n    // function test_cannot_update_rates_without_consent() public {\n    //     // TODO need a way to fake `lender` so mutualConsentById will fail\n    //     loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n    //     loan.addCredit(drawnRate, facilityRate, 1 ether, address(supportedToken1), lender);\n    //     bytes32 id = loan.ids(0);\n      \n\n    //     // try to mock lender address as someone else\n    //     loan.setRates(id, uint128(1 ether), uint128(1 ether));\n    //     loan.setRates(id, uint128(1 ether), uint128(1 ether));\n    //     (uint128 drate, uint128 frate,) = loan.interestRate().rates(id);\n    //     assertEq(facilityRate, frate);\n    //     assertEq(drawnRate, drate);\n    // }\n\n\n}\n"
    },
    "contracts/utils/LoanLib.t.sol": {
      "content": "pragma solidity 0.8.9;\n\nimport { DSTest } from \"../../lib/ds-test/src/test.sol\";\nimport { CreditListLib } from \"./CreditListLib.sol\";\nimport { CreditLib } from \"./CreditLib.sol\";\n\ncontract LoanLibTest is DSTest {\n    using CreditListLib for bytes32[];\n    bytes32[] private ids;\n\n    address lender = address(0);\n    address loan = address(1);\n    address token = address(2);\n\n    function test_computes_the_same_position_id() public view {\n        bytes32 id = CreditLib.computePositionId(loan, lender, token);\n        bytes32 id2 = CreditLib.computePositionId(loan, lender, token);\n        assert(id == id2);\n    }\n\n    function test_computes_a_different_position_id() public view {\n        bytes32 id = CreditLib.computePositionId(loan, lender, token);\n        bytes32 id2 = CreditLib.computePositionId(loan, address(this), token);\n        assert(id != id2);\n        bytes32 idSameInputsDifferentOrder = CreditLib.computePositionId(lender, loan, token);\n        assert(idSameInputsDifferentOrder != id);\n    }\n\n    function test_can_remove_position() public {\n        bytes32 id = CreditLib.computePositionId(loan, lender, token);\n        bytes32 id2 = CreditLib.computePositionId(loan, address(this), token);\n        ids.push(id);\n        ids.push(id2);\n        \n        assert(ids.length == 2);\n        ids.removePosition(id2);\n        assert(ids.length == 2); // not deleted, only null\n\n        assert(ids[0] == id);\n        assert(ids[1] == bytes32(0)); // ensure deleted\n    }\n\n    function testFail_cannot_remove_non_existent_position() public {\n        bytes32 id = CreditLib.computePositionId(loan, lender, token);\n        ids[0] = id;\n        assert(ids.length == 1);\n        ids.removePosition(bytes32(0));\n    }\n\n\n    function test_can_properly_step_queue(uint256 length) public {\n        uint l = 10;\n        ids = new bytes32[](l);\n        if(length == 0 || length > ids.length) { return; } // ensure array is within reasonable bounds\n        if(length == 1) {\n            ids[0] = bytes32(0);\n            ids.stepQ();\n            assertEq(ids[0], ids[0]);\n            return;\n        }\n\n        if(length == 2) {\n            ids[0] = bytes32(0);\n            ids[1] = bytes32(uint(1));\n\n            ids.stepQ();\n            assertEq(ids[0], bytes32(uint(1)));\n            assertEq(ids[1], bytes32(0));\n            return;\n        }\n\n        for(uint256 i = 0; i < length; i++) {\n          ids[i] == bytes32(i);\n        }\n        ids.stepQ();\n        \n        assertEq(ids.length, l);\n        \n        for(uint256 i = 0; i < l; i++) {\n          if(i == 0) assertEq(ids[i], ids[l - 1]); // first -> last\n          else assertEq(ids[i], ids[i - 1]);      // all others move one index down\n        }\n    }\n\n    function test_calculates_right_price_w_decimals(int256 price, uint256 amount) public {\n        // no negative values, base 0 \n        if(price < 0) return;\n        // TODO constrain params so price * amount doesn't overflow\n\n        uint realPrice = uint256(price);\n        uint8 decimals = 18;\n        uint8 decimals2 = 1;\n        \n\n        uint val = CreditLib.calculateValue(price, amount, decimals);\n        assertEq(val,  realPrice * amount * ( 1 * 10 ** decimals));\n\n        uint val2 = CreditLib.calculateValue(price, amount, decimals2);\n        assertEq(val2,  realPrice * amount * ( 1 * 10 ** decimals2));\n    }\n}\n"
    },
    "contracts/modules/oracle/Oracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/FeedRegistryInterface.sol\";\nimport \"../../interfaces/IOracle.sol\";\n\ncontract Oracle is IOracle {\n    FeedRegistryInterface internal registry;\n    address public USD = 0x0000000000000000000000000000000000000348;\n\n    constructor(address _registry) {\n        registry = FeedRegistryInterface(_registry);\n    }\n\n    /**\n     * Returns the latest price in USD\n     */\n    function getLatestAnswer(address token) external returns (int) {\n        (\n            /* uint80 roundID */, \n            int price,\n            /* uint80 startedAt */,\n            /* uint80 timeStamp */,\n            /* uint80 answeredInRound */\n        ) = registry.latestRoundData(token, USD); // ALL PRICES WILL HAVE 8 DECIMAL PADDING\n        \n        return price;\n    }\n\n    \n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/FeedRegistryInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nimport \"./AggregatorV2V3Interface.sol\";\n\ninterface FeedRegistryInterface {\n  struct Phase {\n    uint16 phaseId;\n    uint80 startingAggregatorRoundId;\n    uint80 endingAggregatorRoundId;\n  }\n\n  event FeedProposed(\n    address indexed asset,\n    address indexed denomination,\n    address indexed proposedAggregator,\n    address currentAggregator,\n    address sender\n  );\n  event FeedConfirmed(\n    address indexed asset,\n    address indexed denomination,\n    address indexed latestAggregator,\n    address previousAggregator,\n    uint16 nextPhaseId,\n    address sender\n  );\n\n  // V3 AggregatorV3Interface\n\n  function decimals(address base, address quote) external view returns (uint8);\n\n  function description(address base, address quote) external view returns (string memory);\n\n  function version(address base, address quote) external view returns (uint256);\n\n  function latestRoundData(address base, address quote)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function getRoundData(\n    address base,\n    address quote,\n    uint80 _roundId\n  )\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  // V2 AggregatorInterface\n\n  function latestAnswer(address base, address quote) external view returns (int256 answer);\n\n  function latestTimestamp(address base, address quote) external view returns (uint256 timestamp);\n\n  function latestRound(address base, address quote) external view returns (uint256 roundId);\n\n  function getAnswer(\n    address base,\n    address quote,\n    uint256 roundId\n  ) external view returns (int256 answer);\n\n  function getTimestamp(\n    address base,\n    address quote,\n    uint256 roundId\n  ) external view returns (uint256 timestamp);\n\n  // Registry getters\n\n  function getFeed(address base, address quote) external view returns (AggregatorV2V3Interface aggregator);\n\n  function getPhaseFeed(\n    address base,\n    address quote,\n    uint16 phaseId\n  ) external view returns (AggregatorV2V3Interface aggregator);\n\n  function isFeedEnabled(address aggregator) external view returns (bool);\n\n  function getPhase(\n    address base,\n    address quote,\n    uint16 phaseId\n  ) external view returns (Phase memory phase);\n\n  // Round helpers\n\n  function getRoundFeed(\n    address base,\n    address quote,\n    uint80 roundId\n  ) external view returns (AggregatorV2V3Interface aggregator);\n\n  function getPhaseRange(\n    address base,\n    address quote,\n    uint16 phaseId\n  ) external view returns (uint80 startingRoundId, uint80 endingRoundId);\n\n  function getPreviousRoundId(\n    address base,\n    address quote,\n    uint80 roundId\n  ) external view returns (uint80 previousRoundId);\n\n  function getNextRoundId(\n    address base,\n    address quote,\n    uint80 roundId\n  ) external view returns (uint80 nextRoundId);\n\n  // Feed management\n\n  function proposeFeed(\n    address base,\n    address quote,\n    address aggregator\n  ) external;\n\n  function confirmFeed(\n    address base,\n    address quote,\n    address aggregator\n  ) external;\n\n  // Proposed aggregator\n\n  function getProposedFeed(address base, address quote)\n    external\n    view\n    returns (AggregatorV2V3Interface proposedAggregator);\n\n  function proposedGetRoundData(\n    address base,\n    address quote,\n    uint80 roundId\n  )\n    external\n    view\n    returns (\n      uint80 id,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function proposedLatestRoundData(address base, address quote)\n    external\n    view\n    returns (\n      uint80 id,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  // Phases\n  function getCurrentPhaseId(address base, address quote) external view returns (uint16 currentPhaseId);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n\n  function latestTimestamp() external view returns (uint256);\n\n  function latestRound() external view returns (uint256);\n\n  function getAnswer(uint256 roundId) external view returns (int256);\n\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "contracts/modules/interest-rate/InterestRateCredit.t.sol": {
      "content": "\npragma solidity ^0.8.9;\n\nimport { DSTest } from  \"../../../lib/ds-test/src/test.sol\";\n\nimport { InterestRateCredit } from  \"./InterestRateCredit.sol\";\n\n/**\n * @notice\n * @dev - does not test spigot integration e.g. claimEscrow() since that should already be covered in Spigot tests\n *      - these tests would fail if that assumption was wrong anyway\n */\ncontract SpigotedLoanTest is DSTest {\n    InterestRateCredit i;\n\n    function setUp() public {\n      i = new InterestRateCredit();\n    }\n\n    function test_can_add_different_rates() public {\n      i.setRate(bytes32(\"\"), uint128(0), uint128(0));\n      i.setRate(bytes32(\"1\"), uint128(1), uint128(1));\n    }\n\n    function test_can_accrue_interest_all_drawn() public {\n      i.setRate(bytes32(\"\"), uint128(0), uint128(0));\n      uint accrued = i.accrueInterest(bytes32(0), 1, 1);\n      assertEq(accrued, 0); // TODO: figure out how to fast forward blocks in hevm to test real amounts\n    }\n\n\n    function test_can_accrue_interest_half_drawn() public {\n      i.setRate(bytes32(\"\"), uint128(0), uint128(0));\n      uint accrued = i.accrueInterest(bytes32(0), 1, 2);\n      assertEq(accrued, 0); // TODO: figure out how to fast forward blocks in hevm to test real amounts\n    }\n\n\n    function test_can_accrue_interest_none_drawn() public {\n      i.setRate(bytes32(\"\"), uint128(0), uint128(0));\n      uint accrued = i.accrueInterest(bytes32(0), 0, 1);\n      assertEq(accrued, 0); // TODO: figure out how to fast forward blocks in hevm to test real amounts\n    }\n}\n"
    },
    "contracts/interfaces/IModule.sol": {
      "content": ""
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}